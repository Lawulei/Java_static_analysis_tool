[
  {
    "project": "commons-cli",
    "className": "DefaultParser",
    "methodName": "handleProperties",
    "complexity": 12,
    "loc": 30,
    "code": "/**\r\n * Sets the values of Options using the values in {@code properties}.\r\n *\r\n * @param properties The value properties to be processed.\r\n */\r\nprivate void handleProperties(final Properties properties) throws ParseException {\r\n    if (properties \u003d\u003d null) {\r\n        return;\r\n    }\r\n    for (final Enumeration\u003c?\u003e e \u003d properties.propertyNames(); e.hasMoreElements(); ) {\r\n        final String option \u003d e.nextElement().toString();\r\n        final Option opt \u003d options.getOption(option);\r\n        if (opt \u003d\u003d null) {\r\n            throw new UnrecognizedOptionException(\"Default option wasn\u0027t defined\", option);\r\n        }\r\n        // if the option is part of a group, check if another option of the group has been selected\r\n        final OptionGroup group \u003d options.getOptionGroup(opt);\r\n        final boolean selected \u003d group !\u003d null \u0026\u0026 group.isSelected();\r\n        if (!cmd.hasOption(option) \u0026\u0026 !selected) {\r\n            // get the value from the properties\r\n            final String value \u003d properties.getProperty(option);\r\n            if (opt.hasArg()) {\r\n                if (Util.isEmpty(opt.getValues())) {\r\n                    opt.processValue(stripLeadingAndTrailingQuotesDefaultOff(value));\r\n                }\r\n            } else if (!(\"yes\".equalsIgnoreCase(value) || \"true\".equalsIgnoreCase(value) || \"1\".equalsIgnoreCase(value))) {\r\n                // if the value is not yes, true or 1 then don\u0027t add the option to the CommandLine\r\n                continue;\r\n            }\r\n            handleOption(opt);\r\n            currentOption \u003d null;\r\n        }\r\n    }\r\n}"
  },
  {
    "project": "commons-cli",
    "className": "DefaultParser",
    "methodName": "handleShortAndLongOption",
    "complexity": 13,
    "loc": 62,
    "code": "/**\r\n * Handles the following tokens:\r\n *\r\n * -S -SV -S V -S\u003dV -S1S2 -S1S2 V -SV1\u003dV2\r\n *\r\n * -L -LV -L V -L\u003dV -l\r\n *\r\n * @param hyphenToken the command line token to handle\r\n */\r\nprivate void handleShortAndLongOption(final String hyphenToken) throws ParseException {\r\n    final String token \u003d Util.stripLeadingHyphens(hyphenToken);\r\n    final int pos \u003d indexOfEqual(token);\r\n    if (token.length() \u003d\u003d 1) {\r\n        // -S\r\n        if (options.hasShortOption(token)) {\r\n            handleOption(options.getOption(token));\r\n        } else {\r\n            handleUnknownToken(hyphenToken);\r\n        }\r\n    } else if (pos \u003d\u003d -1) {\r\n        // no equal sign found (-xxx)\r\n        if (options.hasShortOption(token)) {\r\n            handleOption(options.getOption(token));\r\n        } else if (!getMatchingLongOptions(token).isEmpty()) {\r\n            // -L or -l\r\n            handleLongOptionWithoutEqual(hyphenToken);\r\n        } else {\r\n            // look for a long prefix (-Xmx512m)\r\n            final String opt \u003d getLongPrefix(token);\r\n            if (opt !\u003d null \u0026\u0026 options.getOption(opt).acceptsArg()) {\r\n                handleOption(options.getOption(opt));\r\n                currentOption.processValue(stripLeadingAndTrailingQuotesDefaultOff(token.substring(opt.length())));\r\n                currentOption \u003d null;\r\n            } else if (isJavaProperty(token)) {\r\n                // -SV1 (-Dflag)\r\n                handleOption(options.getOption(token.substring(0, 1)));\r\n                currentOption.processValue(stripLeadingAndTrailingQuotesDefaultOff(token.substring(1)));\r\n                currentOption \u003d null;\r\n            } else {\r\n                // -S1S2S3 or -S1S2V\r\n                handleConcatenatedOptions(hyphenToken);\r\n            }\r\n        }\r\n    } else {\r\n        // equal sign found (-xxx\u003dyyy)\r\n        final String opt \u003d token.substring(0, pos);\r\n        final String value \u003d token.substring(pos + 1);\r\n        if (opt.length() \u003d\u003d 1) {\r\n            // -S\u003dV\r\n            final Option option \u003d options.getOption(opt);\r\n            if (option !\u003d null \u0026\u0026 option.acceptsArg()) {\r\n                handleOption(option);\r\n                currentOption.processValue(value);\r\n                currentOption \u003d null;\r\n            } else {\r\n                handleUnknownToken(hyphenToken);\r\n            }\r\n        } else if (isJavaProperty(opt)) {\r\n            // -SV1\u003dV2 (-Dkey\u003dvalue)\r\n            handleOption(options.getOption(opt.substring(0, 1)));\r\n            currentOption.processValue(opt.substring(1));\r\n            currentOption.processValue(value);\r\n            currentOption \u003d null;\r\n        } else {\r\n            // -L\u003dV or -l\u003dV\r\n            handleLongOptionWithEqual(hyphenToken);\r\n        }\r\n    }\r\n}"
  },
  {
    "project": "commons-cli",
    "className": "DefaultParser",
    "methodName": "handleToken",
    "complexity": 12,
    "loc": 21,
    "code": "/**\r\n * Handles any command line token.\r\n *\r\n * @param token the command line token to handle\r\n * @throws ParseException\r\n */\r\nprivate void handleToken(final String token) throws ParseException {\r\n    if (token !\u003d null) {\r\n        currentToken \u003d token;\r\n        if (skipParsing) {\r\n            cmd.addArg(token);\r\n        } else if (\"--\".equals(token)) {\r\n            skipParsing \u003d true;\r\n        } else if (currentOption !\u003d null \u0026\u0026 currentOption.acceptsArg() \u0026\u0026 isArgument(token)) {\r\n            currentOption.processValue(stripLeadingAndTrailingQuotesDefaultOn(token));\r\n        } else if (token.startsWith(\"--\")) {\r\n            handleLongOption(token);\r\n        } else if (token.startsWith(\"-\") \u0026\u0026 !\"-\".equals(token)) {\r\n            handleShortAndLongOption(token);\r\n        } else {\r\n            handleUnknownToken(token);\r\n        }\r\n        if (currentOption !\u003d null \u0026\u0026 !currentOption.acceptsArg()) {\r\n            currentOption \u003d null;\r\n        }\r\n    }\r\n}"
  },
  {
    "project": "commons-cli",
    "className": "GnuParser",
    "methodName": "flatten",
    "complexity": 12,
    "loc": 45,
    "code": "/**\r\n * This flatten method does so using the following rules:\r\n * \u003col\u003e\r\n * \u003cli\u003eIf an {@link Option} exists for the first character of the {@code arguments} entry \u003cstrong\u003eAND\u003c/strong\u003e an\r\n * {@link Option} does not exist for the whole {@code argument} then add the first character as an option to the\r\n * processed tokens list for example \"-D\" and add the rest of the entry to the also.\u003c/li\u003e\r\n * \u003cli\u003eOtherwise just add the token to the processed tokens list.\u003c/li\u003e\r\n * \u003c/ol\u003e\r\n *\r\n * @param options The Options to parse the arguments by.\r\n * @param arguments The arguments that have to be flattened.\r\n * @param stopAtNonOption specifies whether to stop flattening when a non option has been encountered\r\n * @return a String array of the flattened arguments\r\n */\r\n@Override\r\nprotected String[] flatten(final Options options, final String[] arguments, final boolean stopAtNonOption) {\r\n    final List\u003cString\u003e tokens \u003d new ArrayList\u003c\u003e();\r\n    boolean eatTheRest \u003d false;\r\n    for (int i \u003d 0; i \u003c arguments.length; i++) {\r\n        final String arg \u003d arguments[i];\r\n        if (arg !\u003d null) {\r\n            if (\"--\".equals(arg)) {\r\n                eatTheRest \u003d true;\r\n                tokens.add(\"--\");\r\n            } else if (\"-\".equals(arg)) {\r\n                tokens.add(\"-\");\r\n            } else if (arg.startsWith(\"-\")) {\r\n                final String opt \u003d Util.stripLeadingHyphens(arg);\r\n                if (options.hasOption(opt)) {\r\n                    tokens.add(arg);\r\n                } else {\r\n                    final int equalPos \u003d DefaultParser.indexOfEqual(opt);\r\n                    if (equalPos !\u003d -1 \u0026\u0026 options.hasOption(opt.substring(0, equalPos))) {\r\n                        // the format is --foo\u003dvalue or -foo\u003dvalue\r\n                        // --foo\r\n                        tokens.add(arg.substring(0, arg.indexOf(Char.EQUAL)));\r\n                        // value\r\n                        tokens.add(arg.substring(arg.indexOf(Char.EQUAL) + 1));\r\n                    } else if (options.hasOption(arg.substring(0, 2))) {\r\n                        // the format is a special properties option (-Dproperty\u003dvalue)\r\n                        // -D\r\n                        tokens.add(arg.substring(0, 2));\r\n                        // property\u003dvalue\r\n                        tokens.add(arg.substring(2));\r\n                    } else {\r\n                        eatTheRest \u003d stopAtNonOption;\r\n                        tokens.add(arg);\r\n                    }\r\n                }\r\n            } else {\r\n                tokens.add(arg);\r\n            }\r\n            if (eatTheRest) {\r\n                for (i++; i \u003c arguments.length; i++) {\r\n                    // NOPMD\r\n                    tokens.add(arguments[i]);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return tokens.toArray(Util.EMPTY_STRING_ARRAY);\r\n}"
  },
  {
    "project": "commons-cli",
    "className": "TextHelpAppendable",
    "methodName": "adjustTableFormat",
    "complexity": 13,
    "loc": 51,
    "code": "/**\r\n * Adjusts the table format.\r\n * \u003cp\u003e\r\n * Given the width of the page and the size of the table attempt to resize the columns to fit the page width if necessary. Adjustments are made as follows:\r\n * \u003c/p\u003e\r\n * \u003cul\u003e\r\n * \u003cli\u003eThe minimum size for a column may not be smaller than the length of the column header\u003c/li\u003e\r\n * \u003cli\u003eThe maximum size is set to the maximum of the length of the header or the longest line length.\u003c/li\u003e\r\n * \u003cli\u003eIf the total size of the columns is greater than the page wight, adjust the size of VARIABLE columns to attempt reduce the width to the the maximum\r\n * size.\r\n * \u003c/ul\u003e\r\n * \u003cp\u003e\r\n * Note: it is possible for the size of the columns to exceed the declared page width. In this case the table will extend beyond the desired page width.\r\n * \u003c/p\u003e\r\n *\r\n * @param table the table to adjust.\r\n * @return a new TableDefinition with adjusted values.\r\n */\r\nprotected TableDefinition adjustTableFormat(final TableDefinition table) {\r\n    final List\u003cTextStyle.Builder\u003e styleBuilders \u003d new ArrayList\u003c\u003e();\r\n    for (int i \u003d 0; i \u003c table.columnTextStyles().size(); i++) {\r\n        final TextStyle style \u003d table.columnTextStyles().get(i);\r\n        final TextStyle.Builder builder \u003d TextStyle.builder().setTextStyle(style);\r\n        styleBuilders.add(builder);\r\n        final String header \u003d table.headers().get(i);\r\n        if (style.getMaxWidth() \u003c header.length() || style.getMaxWidth() \u003d\u003d TextStyle.UNSET_MAX_WIDTH) {\r\n            builder.setMaxWidth(header.length());\r\n        }\r\n        if (style.getMinWidth() \u003c header.length()) {\r\n            builder.setMinWidth(header.length());\r\n        }\r\n        for (final List\u003cString\u003e row : table.rows()) {\r\n            final String cell \u003d row.get(i);\r\n            if (cell.length() \u003e builder.getMaxWidth()) {\r\n                builder.setMaxWidth(cell.length());\r\n            }\r\n        }\r\n    }\r\n    // calculate the total width.\r\n    int calcWidth \u003d 0;\r\n    int adjustedMaxWidth \u003d textStyleBuilder.getMaxWidth();\r\n    for (final TextStyle.Builder builder : styleBuilders) {\r\n        adjustedMaxWidth -\u003d builder.getLeftPad();\r\n        if (builder.isScalable()) {\r\n            calcWidth +\u003d builder.getMaxWidth();\r\n        } else {\r\n            adjustedMaxWidth -\u003d builder.getMaxWidth();\r\n        }\r\n    }\r\n    // rescale if necessary\r\n    if (calcWidth \u003e adjustedMaxWidth) {\r\n        final double fraction \u003d adjustedMaxWidth * 1.0 / calcWidth;\r\n        for (int i \u003d 0; i \u003c styleBuilders.size(); i++) {\r\n            final TextStyle.Builder builder \u003d styleBuilders.get(i);\r\n            if (builder.isScalable()) {\r\n                // resize and remove the padding from the maxWidth calculation.\r\n                styleBuilders.set(i, resize(builder, fraction));\r\n            }\r\n        }\r\n    }\r\n    // regenerate the styles\r\n    final List\u003cTextStyle\u003e styles \u003d new ArrayList\u003c\u003e();\r\n    for (final TextStyle.Builder builder : styleBuilders) {\r\n        // adjust by removing the padding as it was not accounted for above.\r\n        styles.add(builder.get());\r\n    }\r\n    return TableDefinition.from(table.caption(), styles, table.headers(), table.rows());\r\n}"
  },
  {
    "project": "commons-cli",
    "className": "TextStyle",
    "methodName": "pad",
    "complexity": 11,
    "loc": 46,
    "code": "/**\r\n * Pads a string to the maximum width or optionally to the maximum width - indent.\r\n * \u003cul\u003e\r\n * \u003cli\u003eReturns the string unchanged if it is longer than the specified length.\u003c/li\u003e\r\n * \u003cli\u003eWill add the padding based on the alignment.\u003c/li\u003e\r\n * \u003c/ul\u003e\r\n *\r\n * @param addIndent if {@code true} account for the indent when padding the string.\r\n * @param text      the text to pad.\r\n * @return the padded string.\r\n */\r\npublic CharSequence pad(final boolean addIndent, final CharSequence text) {\r\n    if (text.length() \u003e\u003d maxWidth) {\r\n        return text;\r\n    }\r\n    String indentPad;\r\n    String rest;\r\n    final StringBuilder sb \u003d new StringBuilder();\r\n    switch(alignment) {\r\n        case CENTER:\r\n            int padLen;\r\n            if (maxWidth \u003d\u003d UNSET_MAX_WIDTH) {\r\n                padLen \u003d addIndent ? indent : 0;\r\n            } else {\r\n                padLen \u003d maxWidth - text.length();\r\n            }\r\n            final int left \u003d padLen / 2;\r\n            indentPad \u003d Util.repeatSpace(left);\r\n            rest \u003d Util.repeatSpace(padLen - left);\r\n            sb.append(indentPad).append(text).append(rest);\r\n            break;\r\n        case LEFT:\r\n        case RIGHT:\r\n        default:\r\n            // default should never happen. It is here to keep code coverage happy.\r\n            if (maxWidth \u003d\u003d UNSET_MAX_WIDTH) {\r\n                indentPad \u003d addIndent ? Util.repeatSpace(indent) : \"\";\r\n                rest \u003d \"\";\r\n            } else {\r\n                int restLen \u003d maxWidth - text.length();\r\n                if (addIndent \u0026\u0026 restLen \u003e indent) {\r\n                    indentPad \u003d Util.repeatSpace(indent);\r\n                    restLen -\u003d indent;\r\n                } else {\r\n                    indentPad \u003d \"\";\r\n                }\r\n                rest \u003d Util.repeatSpace(restLen);\r\n            }\r\n            if (alignment \u003d\u003d Alignment.LEFT) {\r\n                sb.append(indentPad).append(text).append(rest);\r\n            } else {\r\n                sb.append(indentPad).append(rest).append(text);\r\n            }\r\n            break;\r\n    }\r\n    return sb.toString();\r\n}"
  },
  {
    "project": "commons-cli",
    "className": "HelpFormatter",
    "methodName": "appendOptions",
    "complexity": 16,
    "loc": 72,
    "code": "/**\r\n * Renders the specified Options and return the rendered Options in a StringBuffer.\r\n *\r\n * @param sb The StringBuffer to place the rendered Options into.\r\n * @param width The number of characters to display per line\r\n * @param options The command line Options\r\n * @param leftPad the number of characters of padding to be prefixed to each line\r\n * @param descPad the number of characters of padding to be prefixed to each description line\r\n * @return the StringBuffer with the rendered Options contents.\r\n * @throws IOException if an I/O error occurs.\r\n */\r\n\u003cA extends Appendable\u003e A appendOptions(final A sb, final int width, final Options options, final int leftPad, final int descPad) throws IOException {\r\n    final String lpad \u003d createPadding(leftPad);\r\n    final String dpad \u003d createPadding(descPad);\r\n    // first create list containing only \u003clpad\u003e-a,--aaa where\r\n    // -a is opt and --aaa is long opt; in parallel look for\r\n    // the longest opt string this list will be then used to\r\n    // sort options ascending\r\n    int max \u003d 0;\r\n    final int maxSince \u003d showSince ? determineMaxSinceLength(options) + leftPad : 0;\r\n    final List\u003cStringBuilder\u003e prefixList \u003d new ArrayList\u003c\u003e();\r\n    final List\u003cOption\u003e optList \u003d options.helpOptions();\r\n    if (getOptionComparator() !\u003d null) {\r\n        Collections.sort(optList, getOptionComparator());\r\n    }\r\n    for (final Option option : optList) {\r\n        final StringBuilder optBuf \u003d new StringBuilder();\r\n        if (option.getOpt() \u003d\u003d null) {\r\n            optBuf.append(lpad).append(\"   \").append(getLongOptPrefix()).append(option.getLongOpt());\r\n        } else {\r\n            optBuf.append(lpad).append(getOptPrefix()).append(option.getOpt());\r\n            if (option.hasLongOpt()) {\r\n                optBuf.append(\u0027,\u0027).append(getLongOptPrefix()).append(option.getLongOpt());\r\n            }\r\n        }\r\n        if (option.hasArg()) {\r\n            final String argName \u003d option.getArgName();\r\n            if (argName !\u003d null \u0026\u0026 argName.isEmpty()) {\r\n                // if the option has a blank argname\r\n                optBuf.append(\u0027 \u0027);\r\n            } else {\r\n                optBuf.append(option.hasLongOpt() ? longOptSeparator : \" \");\r\n                optBuf.append(\"\u003c\").append(argName !\u003d null ? option.getArgName() : getArgName()).append(\"\u003e\");\r\n            }\r\n        }\r\n        prefixList.add(optBuf);\r\n        max \u003d Math.max(optBuf.length() + maxSince, max);\r\n    }\r\n    final int nextLineTabStop \u003d max + descPad;\r\n    if (showSince) {\r\n        final StringBuilder optHeader \u003d new StringBuilder(HEADER_OPTIONS).append(createPadding(max - maxSince - HEADER_OPTIONS.length() + leftPad)).append(HEADER_SINCE);\r\n        optHeader.append(createPadding(max - optHeader.length())).append(lpad).append(HEADER_DESCRIPTION);\r\n        appendWrappedText(sb, width, nextLineTabStop, optHeader.toString());\r\n        sb.append(getNewLine());\r\n    }\r\n    int x \u003d 0;\r\n    for (final Iterator\u003cOption\u003e it \u003d optList.iterator(); it.hasNext(); ) {\r\n        final Option option \u003d it.next();\r\n        final StringBuilder optBuf \u003d new StringBuilder(prefixList.get(x++).toString());\r\n        if (optBuf.length() \u003c max) {\r\n            optBuf.append(createPadding(max - maxSince - optBuf.length()));\r\n            if (showSince) {\r\n                optBuf.append(lpad).append(option.getSince() \u003d\u003d null ? \"-\" : option.getSince());\r\n            }\r\n            optBuf.append(createPadding(max - optBuf.length()));\r\n        }\r\n        optBuf.append(dpad);\r\n        if (deprecatedFormatFunction !\u003d null \u0026\u0026 option.isDeprecated()) {\r\n            optBuf.append(deprecatedFormatFunction.apply(option).trim());\r\n        } else if (option.getDescription() !\u003d null) {\r\n            optBuf.append(option.getDescription());\r\n        }\r\n        appendWrappedText(sb, width, nextLineTabStop, optBuf.toString());\r\n        if (it.hasNext()) {\r\n            sb.append(getNewLine());\r\n        }\r\n    }\r\n    return sb;\r\n}"
  },
  {
    "project": "commons-cli",
    "className": "HelpFormatter",
    "methodName": "findWrapPos",
    "complexity": 11,
    "loc": 28,
    "code": "/**\r\n * Finds the next text wrap position after {@code startPos} for the text in {@code text} with the column width\r\n * {@code width}. The wrap point is the last position before startPos+width having a whitespace character (space,\r\n * \\n, \\r). If there is no whitespace character before startPos+width, it will return startPos+width.\r\n *\r\n * @param text The text being searched for the wrap position\r\n * @param width width of the wrapped text\r\n * @param startPos position from which to start the lookup whitespace character\r\n * @return position on which the text must be wrapped or -1 if the wrap position is at the end of the text\r\n */\r\nprotected int findWrapPos(final String text, final int width, final int startPos) {\r\n    // the line ends before the max wrap pos or a new line char found\r\n    int pos \u003d text.indexOf(Char.LF, startPos);\r\n    if (pos !\u003d -1 \u0026\u0026 pos \u003c\u003d width) {\r\n        return pos + 1;\r\n    }\r\n    pos \u003d text.indexOf(Char.TAB, startPos);\r\n    if (pos !\u003d -1 \u0026\u0026 pos \u003c\u003d width) {\r\n        return pos + 1;\r\n    }\r\n    if (startPos + width \u003e\u003d text.length()) {\r\n        return -1;\r\n    }\r\n    // look for the last whitespace character before startPos+width\r\n    for (pos \u003d startPos + width; pos \u003e\u003d startPos; --pos) {\r\n        final char c \u003d text.charAt(pos);\r\n        if (c \u003d\u003d Char.SP || c \u003d\u003d Char.LF || c \u003d\u003d Char.CR) {\r\n            break;\r\n        }\r\n    }\r\n    // if we found it - just return\r\n    if (pos \u003e startPos) {\r\n        return pos;\r\n    }\r\n    // if we didn\u0027t find one, simply chop at startPos+width\r\n    pos \u003d startPos + width;\r\n    return pos \u003d\u003d text.length() ? -1 : pos;\r\n}"
  },
  {
    "project": "commons-cli",
    "className": "Parser",
    "methodName": "parse",
    "complexity": 15,
    "loc": 61,
    "code": "/**\r\n * Parse the arguments according to the specified options and properties.\r\n *\r\n * @param options the specified Options\r\n * @param arguments the command line arguments\r\n * @param properties command line option name-value pairs\r\n * @param stopAtNonOption if {@code true} an unrecognized argument stops the parsing and the remaining arguments\r\n *        are added to the {@link CommandLine}s args list. If {@code false} an unrecognized argument triggers a\r\n *        ParseException.\r\n * @return the list of atomic option and value tokens\r\n * @throws ParseException if there are any problems encountered while parsing the command line tokens.\r\n * @since 1.1\r\n */\r\npublic CommandLine parse(final Options options, final String[] arguments, final Properties properties, final boolean stopAtNonOption) throws ParseException {\r\n    // clear out the data in options in case it\u0027s been used before (CLI-71)\r\n    for (final Option opt : options.helpOptions()) {\r\n        opt.clearValues();\r\n    }\r\n    // clear the data from the groups\r\n    for (final OptionGroup group : options.getOptionGroups()) {\r\n        group.setSelected(null);\r\n    }\r\n    // initialize members\r\n    setOptions(options);\r\n    cmd \u003d CommandLine.builder().get();\r\n    boolean eatTheRest \u003d false;\r\n    final List\u003cString\u003e tokenList \u003d Arrays.asList(flatten(getOptions(), arguments \u003d\u003d null ? new String[0] : arguments, stopAtNonOption));\r\n    final ListIterator\u003cString\u003e iterator \u003d tokenList.listIterator();\r\n    // process each flattened token\r\n    while (iterator.hasNext()) {\r\n        final String token \u003d iterator.next();\r\n        if (token !\u003d null) {\r\n            // the value is the double-dash\r\n            if (\"--\".equals(token)) {\r\n                eatTheRest \u003d true;\r\n            } else if (\"-\".equals(token)) {\r\n                // the value is a single dash\r\n                if (stopAtNonOption) {\r\n                    eatTheRest \u003d true;\r\n                } else {\r\n                    cmd.addArg(token);\r\n                }\r\n            } else if (token.startsWith(\"-\")) {\r\n                // the value is an option\r\n                if (stopAtNonOption \u0026\u0026 !getOptions().hasOption(token)) {\r\n                    eatTheRest \u003d true;\r\n                    cmd.addArg(token);\r\n                } else {\r\n                    processOption(token, iterator);\r\n                }\r\n            } else {\r\n                // the value is an argument\r\n                cmd.addArg(token);\r\n                if (stopAtNonOption) {\r\n                    eatTheRest \u003d true;\r\n                }\r\n            }\r\n            // eat the remaining tokens\r\n            if (eatTheRest) {\r\n                while (iterator.hasNext()) {\r\n                    final String str \u003d iterator.next();\r\n                    // ensure only one double-dash is added\r\n                    if (!\"--\".equals(str)) {\r\n                        cmd.addArg(str);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    processProperties(properties);\r\n    checkRequiredOptions();\r\n    return cmd;\r\n}"
  },
  {
    "project": "commons-cli",
    "className": "Parser",
    "methodName": "processProperties",
    "complexity": 12,
    "loc": 34,
    "code": "/**\r\n * Sets the values of Options using the values in {@code properties}.\r\n *\r\n * @param properties The value properties to be processed.\r\n * @throws ParseException if there are any problems encountered while processing the properties.\r\n */\r\nprotected void processProperties(final Properties properties) throws ParseException {\r\n    if (properties \u003d\u003d null) {\r\n        return;\r\n    }\r\n    for (final Enumeration\u003c?\u003e e \u003d properties.propertyNames(); e.hasMoreElements(); ) {\r\n        final String option \u003d e.nextElement().toString();\r\n        final Option opt \u003d options.getOption(option);\r\n        if (opt \u003d\u003d null) {\r\n            throw new UnrecognizedOptionException(\"Default option wasn\u0027t defined\", option);\r\n        }\r\n        // if the option is part of a group, check if another option of the group has been selected\r\n        final OptionGroup group \u003d options.getOptionGroup(opt);\r\n        final boolean selected \u003d group !\u003d null \u0026\u0026 group.isSelected();\r\n        if (!cmd.hasOption(option) \u0026\u0026 !selected) {\r\n            // get the value from the properties instance\r\n            final String value \u003d properties.getProperty(option);\r\n            if (opt.hasArg()) {\r\n                if (Util.isEmpty(opt.getValues())) {\r\n                    try {\r\n                        opt.processValue(value);\r\n                    } catch (final RuntimeException exp) {\r\n                        // NOPMD\r\n                        // if we cannot add the value don\u0027t worry about it\r\n                    }\r\n                }\r\n            } else if (!(\"yes\".equalsIgnoreCase(value) || \"true\".equalsIgnoreCase(value) || \"1\".equalsIgnoreCase(value))) {\r\n                // if the value is not yes, true or 1 then don\u0027t add the\r\n                // option to the CommandLine\r\n                continue;\r\n            }\r\n            cmd.addOption(opt);\r\n            updateRequiredOptions(opt);\r\n        }\r\n    }\r\n}"
  },
  {
    "project": "commons-cli",
    "className": "PatternOptionBuilder",
    "methodName": "parsePattern",
    "complexity": 6,
    "loc": 51,
    "code": "/**\r\n * Returns the {@link Options} instance represented by {@code pattern}.\r\n *\r\n * @param pattern the pattern string\r\n * @return The {@link Options} instance\r\n */\r\npublic static Options parsePattern(final String pattern) {\r\n    char opt \u003d Char.SP;\r\n    boolean required \u003d false;\r\n    Class\u003c?\u003e type \u003d null;\r\n    Converter\u003c?, ?\u003e converter \u003d Converter.DEFAULT;\r\n    final Options options \u003d new Options();\r\n    for (int i \u003d 0; i \u003c pattern.length(); i++) {\r\n        final char ch \u003d pattern.charAt(i);\r\n        // a value code comes after an option and specifies\r\n        // details about it\r\n        if (!isValueCode(ch)) {\r\n            if (opt !\u003d Char.SP) {\r\n                // @formatter:off\r\n                final Option option \u003d Option.builder(String.valueOf(opt)).hasArg(type !\u003d null).required(required).type(type).converter(converter).build();\r\n                // @formatter:on\r\n                // we have a previous one to deal with\r\n                options.addOption(option);\r\n                required \u003d false;\r\n                type \u003d null;\r\n                converter \u003d Converter.DEFAULT;\r\n            }\r\n            opt \u003d ch;\r\n        } else if (ch \u003d\u003d \u0027!\u0027) {\r\n            required \u003d true;\r\n        } else {\r\n            type \u003d getValueType(ch);\r\n            final Map\u003cClass\u003c?\u003e, Converter\u003c?, ? extends Throwable\u003e\u003e map \u003d TypeHandler.createDefaultMap();\r\n            // Backward compatibility (probably).\r\n            map.put(FILES_VALUE, unsupported());\r\n            converter \u003d new TypeHandler(map).getConverter(getValueType(ch));\r\n        }\r\n    }\r\n    if (opt !\u003d Char.SP) {\r\n        final Option option \u003d Option.builder(String.valueOf(opt)).hasArg(type !\u003d null).required(required).type(type).build();\r\n        // we have a final one to deal with\r\n        options.addOption(option);\r\n    }\r\n    return options;\r\n}"
  },
  {
    "project": "commons-cli",
    "className": "PosixParser",
    "methodName": "flatten",
    "complexity": 14,
    "loc": 56,
    "code": "/**\r\n * \u003cp\u003e\r\n * An implementation of {@link Parser}\u0027s abstract {@link Parser#flatten(Options,String[],boolean) flatten} method.\r\n * \u003c/p\u003e\r\n *\r\n * \u003cp\u003e\r\n * The following are the rules used by this flatten method.\r\n * \u003c/p\u003e\r\n * \u003col\u003e\r\n * \u003cli\u003eif {@code stopAtNonOption} is \u003cstrong\u003etrue\u003c/strong\u003e then do not burst anymore of {@code arguments} entries, just\r\n * add each successive entry without further processing. Otherwise, ignore {@code stopAtNonOption}.\u003c/li\u003e\r\n * \u003cli\u003eif the current {@code arguments} entry is \"\u003cstrong\u003e--\u003c/strong\u003e\" just add the entry to the list of processed\r\n * tokens\u003c/li\u003e\r\n * \u003cli\u003eif the current {@code arguments} entry is \"\u003cstrong\u003e-\u003c/strong\u003e\" just add the entry to the list of processed tokens\u003c/li\u003e\r\n * \u003cli\u003eif the current {@code arguments} entry is two characters in length and the first character is \"\u003cstrong\u003e-\u003c/strong\u003e\"\r\n * then check if this is a valid {@link Option} id. If it is a valid id, then add the entry to the list of processed\r\n * tokens and set the current {@link Option} member. If it is not a valid id and {@code stopAtNonOption} is true,\r\n * then the remaining entries are copied to the list of processed tokens. Otherwise, the current entry is ignored.\u003c/li\u003e\r\n * \u003cli\u003eif the current {@code arguments} entry is more than two characters in length and the first character is\r\n * \"\u003cstrong\u003e-\u003c/strong\u003e\" then we need to burst the entry to determine its constituents. For more information on the bursting\r\n * algorithm see {@link PosixParser#burstToken(String, boolean) burstToken}.\u003c/li\u003e\r\n * \u003cli\u003eif the current {@code arguments} entry is not handled by any of the previous rules, then the entry is added\r\n * to the list of processed tokens.\u003c/li\u003e\r\n * \u003c/ol\u003e\r\n *\r\n * @param options The command line {@link Options}\r\n * @param arguments The command line arguments to be parsed\r\n * @param stopAtNonOption Specifies whether to stop flattening when an non option is found.\r\n * @return The flattened {@code arguments} String array.\r\n */\r\n@Override\r\nprotected String[] flatten(final Options options, final String[] arguments, final boolean stopAtNonOption) throws ParseException {\r\n    init();\r\n    this.options \u003d options;\r\n    // an iterator for the command line tokens\r\n    final Iterator\u003cString\u003e iter \u003d Arrays.asList(arguments).iterator();\r\n    // process each command line token\r\n    while (iter.hasNext()) {\r\n        // get the next command line token\r\n        final String token \u003d iter.next();\r\n        if (token !\u003d null) {\r\n            // single or double hyphen\r\n            if (\"-\".equals(token) || \"--\".equals(token)) {\r\n                tokens.add(token);\r\n            } else if (token.startsWith(\"--\")) {\r\n                // handle long option --foo or --foo\u003dbar\r\n                final int pos \u003d DefaultParser.indexOfEqual(token);\r\n                // --foo\r\n                final String opt \u003d pos \u003d\u003d -1 ? token : token.substring(0, pos);\r\n                final List\u003cString\u003e matchingOpts \u003d options.getMatchingOptions(opt);\r\n                if (matchingOpts.isEmpty()) {\r\n                    processNonOptionToken(token, stopAtNonOption);\r\n                } else if (matchingOpts.size() \u003e 1) {\r\n                    throw new AmbiguousOptionException(opt, matchingOpts);\r\n                } else {\r\n                    currentOption \u003d options.getOption(matchingOpts.get(0));\r\n                    tokens.add(\"--\" + currentOption.getLongOpt());\r\n                    if (pos !\u003d -1) {\r\n                        tokens.add(token.substring(pos + 1));\r\n                    }\r\n                }\r\n            } else if (token.startsWith(\"-\")) {\r\n                if (token.length() \u003d\u003d 2 || options.hasOption(token)) {\r\n                    processOptionToken(token, stopAtNonOption);\r\n                } else if (!options.getMatchingOptions(token).isEmpty()) {\r\n                    final List\u003cString\u003e matchingOpts \u003d options.getMatchingOptions(token);\r\n                    if (matchingOpts.size() \u003e 1) {\r\n                        throw new AmbiguousOptionException(token, matchingOpts);\r\n                    }\r\n                    final Option opt \u003d options.getOption(matchingOpts.get(0));\r\n                    processOptionToken(\"-\" + opt.getLongOpt(), stopAtNonOption);\r\n                } else // requires bursting\r\n                {\r\n                    burstToken(token, stopAtNonOption);\r\n                }\r\n            } else {\r\n                processNonOptionToken(token, stopAtNonOption);\r\n            }\r\n        }\r\n        gobble(iter);\r\n    }\r\n    return tokens.toArray(Util.EMPTY_STRING_ARRAY);\r\n}"
  },
  {
    "project": "commons-math",
    "className": "CannonballExample",
    "methodName": "cannonballTest",
    "complexity": 2,
    "loc": 137,
    "code": "public static void cannonballTest(Chart chart) {\r\n    // time interval for each iteration\r\n    final double dt \u003d 0.1;\r\n    // the number of iterations to run\r\n    final int iterations \u003d 144;\r\n    // measurement noise (m)\r\n    final double measurementNoise \u003d 30;\r\n    // initial velocity of the cannonball\r\n    final double initialVelocity \u003d 100;\r\n    // shooting angle\r\n    final double angle \u003d 45;\r\n    // the cannonball itself\r\n    final Cannonball cannonball \u003d new Cannonball(dt, angle, initialVelocity, measurementNoise, 1000);\r\n    // A \u003d [ 1, dt, 0,  0 ]  \u003d\u003e  x(n+1) \u003d x(n) + vx(n)\r\n    //     [ 0,  1, 0,  0 ]  \u003d\u003e vx(n+1) \u003d        vx(n)\r\n    //     [ 0,  0, 1, dt ]  \u003d\u003e  y(n+1) \u003d              y(n) + vy(n)\r\n    //     [ 0,  0, 0,  1 ]  \u003d\u003e vy(n+1) \u003d                     vy(n)\r\n    final RealMatrix A \u003d MatrixUtils.createRealMatrix(new double[][] { { 1, dt, 0, 0 }, { 0, 1, 0, 0 }, { 0, 0, 1, dt }, { 0, 0, 0, 1 } });\r\n    // The control vector, which adds acceleration to the kinematic equations.\r\n    // 0          \u003d\u003e  x(n+1) \u003d  x(n+1)\r\n    // 0          \u003d\u003e vx(n+1) \u003d vx(n+1)\r\n    // -9.81*dt^2 \u003d\u003e  y(n+1) \u003d  y(n+1) - 1/2 * 9.81 * dt^2\r\n    // -9.81*dt   \u003d\u003e vy(n+1) \u003d vy(n+1) - 9.81 * dt\r\n    final RealVector controlVector \u003d MatrixUtils.createRealVector(new double[] { 0, 0, 0.5 * -9.81 * dt * dt, -9.81 * dt });\r\n    // The control matrix B only update y and vy, see control vector\r\n    final RealMatrix B \u003d MatrixUtils.createRealMatrix(new double[][] { { 0, 0, 0, 0 }, { 0, 0, 0, 0 }, { 0, 0, 1, 0 }, { 0, 0, 0, 1 } });\r\n    // After state transition and control, here are the equations:\r\n    //\r\n    //  x(n+1) \u003d x(n) + vx(n)\r\n    // vx(n+1) \u003d vx(n)\r\n    //  y(n+1) \u003d y(n) + vy(n) - 0.5 * 9.81 * dt^2\r\n    // vy(n+1) \u003d vy(n) + -9.81 * dt\r\n    //\r\n    // Which, if you recall, are the equations of motion for a parabola.\r\n    // We only observe the x/y position of the cannonball\r\n    final RealMatrix H \u003d MatrixUtils.createRealMatrix(new double[][] { { 1, 0, 0, 0 }, { 0, 0, 0, 0 }, { 0, 0, 1, 0 }, { 0, 0, 0, 0 } });\r\n    // This is our guess of the initial state.  I intentionally set the Y value\r\n    // wrong to illustrate how fast the Kalman filter will pick up on that.\r\n    final double speedX \u003d cannonball.getXVelocity();\r\n    final double speedY \u003d cannonball.getYVelocity();\r\n    final RealVector initialState \u003d MatrixUtils.createRealVector(new double[] { 0, speedX, 100, speedY });\r\n    // The initial error covariance matrix, the variance \u003d noise^2\r\n    final double var \u003d measurementNoise * measurementNoise;\r\n    final RealMatrix initialErrorCovariance \u003d MatrixUtils.createRealMatrix(new double[][] { { var, 0, 0, 0 }, { 0, 1e-3, 0, 0 }, { 0, 0, var, 0 }, { 0, 0, 0, 1e-3 } });\r\n    // we assume no process noise -\u003e zero matrix\r\n    final RealMatrix Q \u003d MatrixUtils.createRealMatrix(4, 4);\r\n    // the measurement covariance matrix\r\n    final RealMatrix R \u003d MatrixUtils.createRealMatrix(new double[][] { { var, 0, 0, 0 }, { 0, 1e-3, 0, 0 }, { 0, 0, var, 0 }, { 0, 0, 0, 1e-3 } });\r\n    final ProcessModel pm \u003d new DefaultProcessModel(A, B, Q, initialState, initialErrorCovariance);\r\n    final MeasurementModel mm \u003d new DefaultMeasurementModel(H, R);\r\n    final KalmanFilter filter \u003d new KalmanFilter(pm, mm);\r\n    final List\u003cNumber\u003e realX \u003d new ArrayList\u003c\u003e();\r\n    final List\u003cNumber\u003e realY \u003d new ArrayList\u003c\u003e();\r\n    final List\u003cNumber\u003e measuredX \u003d new ArrayList\u003c\u003e();\r\n    final List\u003cNumber\u003e measuredY \u003d new ArrayList\u003c\u003e();\r\n    final List\u003cNumber\u003e kalmanX \u003d new ArrayList\u003c\u003e();\r\n    final List\u003cNumber\u003e kalmanY \u003d new ArrayList\u003c\u003e();\r\n    for (int i \u003d 0; i \u003c iterations; i++) {\r\n        // get real location\r\n        realX.add(cannonball.getX());\r\n        realY.add(cannonball.getY());\r\n        // get measured location\r\n        final double mx \u003d cannonball.getMeasuredX();\r\n        final double my \u003d cannonball.getMeasuredY();\r\n        measuredX.add(mx);\r\n        measuredY.add(my);\r\n        // iterate the cannon simulation to the next timeslice.\r\n        cannonball.step();\r\n        final double[] state \u003d filter.getStateEstimation();\r\n        kalmanX.add(state[0]);\r\n        kalmanY.add(state[2]);\r\n        // update the kalman filter with the measurements\r\n        filter.predict(controlVector);\r\n        filter.correct(new double[] { mx, 0, my, 0 });\r\n    }\r\n    chart.setXAxisTitle(\"Distance (m)\");\r\n    chart.setYAxisTitle(\"Height (m)\");\r\n    Series dataset \u003d chart.addSeries(\"true\", realX, realY);\r\n    dataset.setMarker(SeriesMarker.NONE);\r\n    dataset \u003d chart.addSeries(\"measured\", measuredX, measuredY);\r\n    dataset.setLineStyle(SeriesLineStyle.DOT_DOT);\r\n    dataset.setMarker(SeriesMarker.NONE);\r\n    dataset \u003d chart.addSeries(\"kalman\", kalmanX, kalmanY);\r\n    dataset.setLineColor(Color.red);\r\n    dataset.setLineStyle(SeriesLineStyle.DASH_DASH);\r\n    dataset.setMarker(SeriesMarker.NONE);\r\n}"
  },
  {
    "project": "commons-math",
    "className": "ConstantVoltageExample",
    "methodName": "constantVoltageTest",
    "complexity": 2,
    "loc": 83,
    "code": "/**\r\n * constant voltage test\r\n */\r\npublic static void constantVoltageTest(Chart chart1, Chart chart2) {\r\n    final double voltage \u003d 1.25d;\r\n    // measurement noise (V) - std dev\r\n    final double measurementNoise \u003d 0.2d;\r\n    final double processNoise \u003d 1e-5d;\r\n    final VoltMeter voltMeter \u003d new VoltMeter(voltage, processNoise, measurementNoise, 2);\r\n    // the state transition matrix -\u003e constant\r\n    final RealMatrix A \u003d new Array2DRowRealMatrix(new double[] { 1d });\r\n    // the control matrix -\u003e no control input\r\n    final RealMatrix B \u003d new Array2DRowRealMatrix(new double[] { 0d });\r\n    // the measurement matrix -\u003e we measure the voltage directly\r\n    final RealMatrix H \u003d new Array2DRowRealMatrix(new double[] { 1d });\r\n    // the initial state vector -\u003e slightly wrong\r\n    final RealVector x0 \u003d new ArrayRealVector(new double[] { 1.45 });\r\n    // the process covariance matrix\r\n    final RealMatrix Q \u003d new Array2DRowRealMatrix(new double[] { processNoise * processNoise });\r\n    // the initial error covariance -\u003e assume a large error at the beginning\r\n    final RealMatrix P0 \u003d new Array2DRowRealMatrix(new double[] { 0.1 });\r\n    // the measurement covariance matrix -\u003e put the \"real\" variance\r\n    RealMatrix R \u003d new Array2DRowRealMatrix(new double[] { measurementNoise * measurementNoise });\r\n    final ProcessModel pm \u003d new DefaultProcessModel(A, B, Q, x0, P0);\r\n    final MeasurementModel mm \u003d new DefaultMeasurementModel(H, R);\r\n    final KalmanFilter filter \u003d new KalmanFilter(pm, mm);\r\n    final List\u003cNumber\u003e xAxis \u003d new ArrayList\u003c\u003e();\r\n    final List\u003cNumber\u003e realVoltageSeries \u003d new ArrayList\u003c\u003e();\r\n    final List\u003cNumber\u003e measuredVoltageSeries \u003d new ArrayList\u003c\u003e();\r\n    final List\u003cNumber\u003e kalmanVoltageSeries \u003d new ArrayList\u003c\u003e();\r\n    final List\u003cNumber\u003e covSeries \u003d new ArrayList\u003c\u003e();\r\n    for (int i \u003d 0; i \u003c 300; i++) {\r\n        xAxis.add(i);\r\n        voltMeter.step();\r\n        realVoltageSeries.add(voltMeter.getVoltage());\r\n        // get the measured voltage from the volt meter\r\n        final double measuredVoltage \u003d voltMeter.getMeasuredVoltage();\r\n        measuredVoltageSeries.add(measuredVoltage);\r\n        kalmanVoltageSeries.add(filter.getStateEstimation()[0]);\r\n        covSeries.add(filter.getErrorCovariance()[0][0]);\r\n        filter.predict();\r\n        filter.correct(new double[] { measuredVoltage });\r\n    }\r\n    chart1.setYAxisTitle(\"Voltage\");\r\n    chart1.setXAxisTitle(\"Iteration\");\r\n    Series dataset \u003d chart1.addSeries(\"real\", xAxis, realVoltageSeries);\r\n    dataset.setMarker(SeriesMarker.NONE);\r\n    dataset \u003d chart1.addSeries(\"measured\", xAxis, measuredVoltageSeries);\r\n    dataset.setLineStyle(SeriesLineStyle.DOT_DOT);\r\n    dataset.setMarker(SeriesMarker.NONE);\r\n    dataset \u003d chart1.addSeries(\"filtered\", xAxis, kalmanVoltageSeries);\r\n    dataset.setLineColor(Color.red);\r\n    dataset.setLineStyle(SeriesLineStyle.DASH_DASH);\r\n    dataset.setMarker(SeriesMarker.NONE);\r\n    // Error covariance chart\r\n    chart2.setYAxisTitle(\"(Voltage)²\");\r\n    chart2.setXAxisTitle(\"Iteration\");\r\n    dataset \u003d chart2.addSeries(\"cov\", xAxis, covSeries);\r\n    dataset.setLineColor(Color.black);\r\n    dataset.setLineStyle(SeriesLineStyle.SOLID);\r\n    dataset.setMarker(SeriesMarker.NONE);\r\n}"
  },
  {
    "project": "commons-math",
    "className": "JdkMathTestPerformance",
    "methodName": "testSimpleBenchmark",
    "complexity": 1,
    "loc": 494,
    "code": "@SuppressWarnings(\"boxing\")\r\nprivate static void testSimpleBenchmark() {\r\n    final String SM \u003d \"StrictMath\";\r\n    final String M \u003d \"Math\";\r\n    final String FM \u003d \"JdkMath\";\r\n    final int maxWidth \u003d 15;\r\n    final int numStat \u003d 100;\r\n    final int numCall \u003d RUNS / numStat;\r\n    final double x \u003d Math.random();\r\n    final double y \u003d Math.random();\r\n    PerfTestUtils.timeAndReport(\"log\", maxWidth, numCall, numStat, false, new PerfTestUtils.RunTest(SM) {\r\n\r\n        @Override\r\n        public Double call() throws Exception {\r\n            return StrictMath.log(x);\r\n        }\r\n    }, new PerfTestUtils.RunTest(M) {\r\n\r\n        @Override\r\n        public Double call() throws Exception {\r\n            return Math.log(x);\r\n        }\r\n    }, new PerfTestUtils.RunTest(FM) {\r\n\r\n        @Override\r\n        public Double call() throws Exception {\r\n            return JdkMath.log(x);\r\n        }\r\n    });\r\n    PerfTestUtils.timeAndReport(\"log10\", maxWidth, numCall, numStat, false, new PerfTestUtils.RunTest(SM) {\r\n\r\n        @Override\r\n        public Double call() throws Exception {\r\n            return StrictMath.log10(x);\r\n        }\r\n    }, new PerfTestUtils.RunTest(M) {\r\n\r\n        @Override\r\n        public Double call() throws Exception {\r\n            return Math.log10(x);\r\n        }\r\n    }, new PerfTestUtils.RunTest(FM) {\r\n\r\n        @Override\r\n        public Double call() throws Exception {\r\n            return JdkMath.log10(x);\r\n        }\r\n    });\r\n    PerfTestUtils.timeAndReport(\"log1p\", maxWidth, numCall, numStat, false, new PerfTestUtils.RunTest(SM) {\r\n\r\n        @Override\r\n        public Double call() throws Exception {\r\n            return StrictMath.log1p(x);\r\n        }\r\n    }, new PerfTestUtils.RunTest(M) {\r\n\r\n        @Override\r\n        public Double call() throws Exception {\r\n            return Math.log1p(x);\r\n        }\r\n    }, new PerfTestUtils.RunTest(FM) {\r\n\r\n        @Override\r\n        public Double call() throws Exception {\r\n            return JdkMath.log1p(x);\r\n        }\r\n    });\r\n    PerfTestUtils.timeAndReport(\"pow\", maxWidth, numCall, numStat, false, new PerfTestUtils.RunTest(SM) {\r\n\r\n        @Override\r\n        public Double call() throws Exception {\r\n            return StrictMath.pow(x, y);\r\n        }\r\n    }, new PerfTestUtils.RunTest(M) {\r\n\r\n        @Override\r\n        public Double call() throws Exception {\r\n            return Math.pow(x, y);\r\n        }\r\n    }, new PerfTestUtils.RunTest(FM) {\r\n\r\n        @Override\r\n        public Double call() throws Exception {\r\n            return JdkMath.pow(x, y);\r\n        }\r\n    });\r\n    PerfTestUtils.timeAndReport(\"exp\", maxWidth, numCall, numStat, false, new PerfTestUtils.RunTest(SM) {\r\n\r\n        @Override\r\n        public Double call() throws Exception {\r\n            return StrictMath.exp(x);\r\n        }\r\n    }, new PerfTestUtils.RunTest(M) {\r\n\r\n        @Override\r\n        public Double call() throws Exception {\r\n            return Math.exp(x);\r\n        }\r\n    }, new PerfTestUtils.RunTest(FM) {\r\n\r\n        @Override\r\n        public Double call() throws Exception {\r\n            return JdkMath.exp(x);\r\n        }\r\n    });\r\n    PerfTestUtils.timeAndReport(\"sin\", maxWidth, numCall, numStat, false, new PerfTestUtils.RunTest(SM) {\r\n\r\n        @Override\r\n        public Double call() throws Exception {\r\n            return StrictMath.sin(x);\r\n        }\r\n    }, new PerfTestUtils.RunTest(M) {\r\n\r\n        @Override\r\n        public Double call() throws Exception {\r\n            return Math.sin(x);\r\n        }\r\n    }, new PerfTestUtils.RunTest(FM) {\r\n\r\n        @Override\r\n        public Double call() throws Exception {\r\n            return JdkMath.sin(x);\r\n        }\r\n    });\r\n    PerfTestUtils.timeAndReport(\"asin\", maxWidth, numCall, numStat, false, new PerfTestUtils.RunTest(SM) {\r\n\r\n        @Override\r\n        public Double call() throws Exception {\r\n            return StrictMath.asin(x);\r\n        }\r\n    }, new PerfTestUtils.RunTest(M) {\r\n\r\n        @Override\r\n        public Double call() throws Exception {\r\n            return Math.asin(x);\r\n        }\r\n    }, new PerfTestUtils.RunTest(FM) {\r\n\r\n        @Override\r\n        public Double call() throws Exception {\r\n            return JdkMath.asin(x);\r\n        }\r\n    });\r\n    PerfTestUtils.timeAndReport(\"cos\", maxWidth, numCall, numStat, false, new PerfTestUtils.RunTest(SM) {\r\n\r\n        @Override\r\n        public Double call() throws Exception {\r\n            return StrictMath.cos(x);\r\n        }\r\n    }, new PerfTestUtils.RunTest(M) {\r\n\r\n        @Override\r\n        public Double call() throws Exception {\r\n            return Math.cos(x);\r\n        }\r\n    }, new PerfTestUtils.RunTest(FM) {\r\n\r\n        @Override\r\n        public Double call() throws Exception {\r\n            return JdkMath.cos(x);\r\n        }\r\n    });\r\n    PerfTestUtils.timeAndReport(\"acos\", maxWidth, numCall, numStat, false, new PerfTestUtils.RunTest(SM) {\r\n\r\n        @Override\r\n        public Double call() throws Exception {\r\n            return StrictMath.acos(x);\r\n        }\r\n    }, new PerfTestUtils.RunTest(M) {\r\n\r\n        @Override\r\n        public Double call() throws Exception {\r\n            return Math.acos(x);\r\n        }\r\n    }, new PerfTestUtils.RunTest(FM) {\r\n\r\n        @Override\r\n        public Double call() throws Exception {\r\n            return JdkMath.acos(x);\r\n        }\r\n    });\r\n    PerfTestUtils.timeAndReport(\"tan\", maxWidth, numCall, numStat, false, new PerfTestUtils.RunTest(SM) {\r\n\r\n        @Override\r\n        public Double call() throws Exception {\r\n            return StrictMath.tan(x);\r\n        }\r\n    }, new PerfTestUtils.RunTest(M) {\r\n\r\n        @Override\r\n        public Double call() throws Exception {\r\n            return Math.tan(x);\r\n        }\r\n    }, new PerfTestUtils.RunTest(FM) {\r\n\r\n        @Override\r\n        public Double call() throws Exception {\r\n            return JdkMath.tan(x);\r\n        }\r\n    });\r\n    PerfTestUtils.timeAndReport(\"atan\", maxWidth, numCall, numStat, false, new PerfTestUtils.RunTest(SM) {\r\n\r\n        @Override\r\n        public Double call() throws Exception {\r\n            return StrictMath.atan(x);\r\n        }\r\n    }, new PerfTestUtils.RunTest(M) {\r\n\r\n        @Override\r\n        public Double call() throws Exception {\r\n            return Math.atan(x);\r\n        }\r\n    }, new PerfTestUtils.RunTest(FM) {\r\n\r\n        @Override\r\n        public Double call() throws Exception {\r\n            return JdkMath.atan(x);\r\n        }\r\n    });\r\n    PerfTestUtils.timeAndReport(\"atan2\", maxWidth, numCall, numStat, false, new PerfTestUtils.RunTest(SM) {\r\n\r\n        @Override\r\n        public Double call() throws Exception {\r\n            return StrictMath.atan2(x, y);\r\n        }\r\n    }, new PerfTestUtils.RunTest(M) {\r\n\r\n        @Override\r\n        public Double call() throws Exception {\r\n            return Math.atan2(x, y);\r\n        }\r\n    }, new PerfTestUtils.RunTest(FM) {\r\n\r\n        @Override\r\n        public Double call() throws Exception {\r\n            return JdkMath.atan2(x, y);\r\n        }\r\n    });\r\n    PerfTestUtils.timeAndReport(\"hypot\", maxWidth, numCall, numStat, false, new PerfTestUtils.RunTest(SM) {\r\n\r\n        @Override\r\n        public Double call() throws Exception {\r\n            return StrictMath.hypot(x, y);\r\n        }\r\n    }, new PerfTestUtils.RunTest(M) {\r\n\r\n        @Override\r\n        public Double call() throws Exception {\r\n            return Math.hypot(x, y);\r\n        }\r\n    }, new PerfTestUtils.RunTest(FM) {\r\n\r\n        @Override\r\n        public Double call() throws Exception {\r\n            return JdkMath.hypot(x, y);\r\n        }\r\n    });\r\n    PerfTestUtils.timeAndReport(\"cbrt\", maxWidth, numCall, numStat, false, new PerfTestUtils.RunTest(SM) {\r\n\r\n        @Override\r\n        public Double call() throws Exception {\r\n            return StrictMath.cbrt(x);\r\n        }\r\n    }, new PerfTestUtils.RunTest(M) {\r\n\r\n        @Override\r\n        public Double call() throws Exception {\r\n            return Math.cbrt(x);\r\n        }\r\n    }, new PerfTestUtils.RunTest(FM) {\r\n\r\n        @Override\r\n        public Double call() throws Exception {\r\n            return JdkMath.cbrt(x);\r\n        }\r\n    });\r\n    PerfTestUtils.timeAndReport(\"sqrt\", maxWidth, numCall, numStat, false, new PerfTestUtils.RunTest(SM) {\r\n\r\n        @Override\r\n        public Double call() throws Exception {\r\n            return StrictMath.sqrt(x);\r\n        }\r\n    }, new PerfTestUtils.RunTest(M) {\r\n\r\n        @Override\r\n        public Double call() throws Exception {\r\n            return Math.sqrt(x);\r\n        }\r\n    }, new PerfTestUtils.RunTest(FM) {\r\n\r\n        @Override\r\n        public Double call() throws Exception {\r\n            return JdkMath.sqrt(x);\r\n        }\r\n    });\r\n    PerfTestUtils.timeAndReport(\"cosh\", maxWidth, numCall, numStat, false, new PerfTestUtils.RunTest(SM) {\r\n\r\n        @Override\r\n        public Double call() throws Exception {\r\n            return StrictMath.cosh(x);\r\n        }\r\n    }, new PerfTestUtils.RunTest(M) {\r\n\r\n        @Override\r\n        public Double call() throws Exception {\r\n            return Math.cosh(x);\r\n        }\r\n    }, new PerfTestUtils.RunTest(FM) {\r\n\r\n        @Override\r\n        public Double call() throws Exception {\r\n            return JdkMath.cosh(x);\r\n        }\r\n    });\r\n    PerfTestUtils.timeAndReport(\"sinh\", maxWidth, numCall, numStat, false, new PerfTestUtils.RunTest(SM) {\r\n\r\n        @Override\r\n        public Double call() throws Exception {\r\n            return StrictMath.sinh(x);\r\n        }\r\n    }, new PerfTestUtils.RunTest(M) {\r\n\r\n        @Override\r\n        public Double call() throws Exception {\r\n            return Math.sinh(x);\r\n        }\r\n    }, new PerfTestUtils.RunTest(FM) {\r\n\r\n        @Override\r\n        public Double call() throws Exception {\r\n            return JdkMath.sinh(x);\r\n        }\r\n    });\r\n    PerfTestUtils.timeAndReport(\"tanh\", maxWidth, numCall, numStat, false, new PerfTestUtils.RunTest(SM) {\r\n\r\n        @Override\r\n        public Double call() throws Exception {\r\n            return StrictMath.tanh(x);\r\n        }\r\n    }, new PerfTestUtils.RunTest(M) {\r\n\r\n        @Override\r\n        public Double call() throws Exception {\r\n            return Math.tanh(x);\r\n        }\r\n    }, new PerfTestUtils.RunTest(FM) {\r\n\r\n        @Override\r\n        public Double call() throws Exception {\r\n            return JdkMath.tanh(x);\r\n        }\r\n    });\r\n    PerfTestUtils.timeAndReport(\"expm1\", maxWidth, numCall, numStat, false, new PerfTestUtils.RunTest(SM) {\r\n\r\n        @Override\r\n        public Double call() throws Exception {\r\n            return StrictMath.expm1(x);\r\n        }\r\n    }, new PerfTestUtils.RunTest(M) {\r\n\r\n        @Override\r\n        public Double call() throws Exception {\r\n            return Math.expm1(x);\r\n        }\r\n    }, new PerfTestUtils.RunTest(FM) {\r\n\r\n        @Override\r\n        public Double call() throws Exception {\r\n            return JdkMath.expm1(x);\r\n        }\r\n    });\r\n    PerfTestUtils.timeAndReport(\"abs\", maxWidth, numCall, numStat, false, new PerfTestUtils.RunTest(SM) {\r\n\r\n        @Override\r\n        public Double call() throws Exception {\r\n            return StrictMath.abs(x);\r\n        }\r\n    }, new PerfTestUtils.RunTest(M) {\r\n\r\n        @Override\r\n        public Double call() throws Exception {\r\n            return Math.abs(x);\r\n        }\r\n    }, new PerfTestUtils.RunTest(FM) {\r\n\r\n        @Override\r\n        public Double call() throws Exception {\r\n            return JdkMath.abs(x);\r\n        }\r\n    });\r\n}"
  },
  {
    "project": "commons-math",
    "className": "PerfTestUtils",
    "methodName": "timesAndResults",
    "complexity": 7,
    "loc": 53,
    "code": "/**\r\n * Timing.\r\n *\r\n * @param repeatChunk Each timing measurement will done done for that\r\n * number of repeats of the code.\r\n * @param repeatStat Timing will be averaged over that number of runs.\r\n * @param runGC Call {@code System.gc()} between each timed block. When\r\n * set to {@code true}, the test will run much slower.\r\n * @param methods Codes being timed.\r\n * @return for each of the given {@code methods} (first dimension), and\r\n * each of the {@code repeatStat} runs (second dimension):\r\n * \u003cul\u003e\r\n *  \u003cli\u003e\r\n *   the average time (in milliseconds) taken by a single call to the\r\n *   {@code call} method (i.e. the time taken by each timed block divided\r\n *   by {@code repeatChunk})\r\n *  \u003c/li\u003e\r\n *  \u003cli\u003e\r\n *   the result returned by the {@code call} method.\r\n *  \u003c/li\u003e\r\n * \u003c/ul\u003e\r\n */\r\n@SafeVarargs\r\npublic static double[][][] timesAndResults(int repeatChunk, int repeatStat, boolean runGC, Callable\u003cDouble\u003e... methods) {\r\n    final int numMethods \u003d methods.length;\r\n    final double[][][] timesAndResults \u003d new double[numMethods][repeatStat][2];\r\n    // Indices into the array containing the methods to benchmark.\r\n    // The purpose is that at each repeat, the \"methods\" are called in a different order.\r\n    final int[] methodSequence \u003d PermutationSampler.natural(numMethods);\r\n    try {\r\n        for (int k \u003d 0; k \u003c repeatStat; k++) {\r\n            PermutationSampler.shuffle(rng, methodSequence);\r\n            for (int n \u003d 0; n \u003c numMethods; n++) {\r\n                // Index of the timed method.\r\n                final int j \u003d methodSequence[n];\r\n                if (runGC) {\r\n                    // Try to perform GC outside the timed block.\r\n                    System.gc();\r\n                }\r\n                final Callable\u003cDouble\u003e r \u003d methods[j];\r\n                final double[] result \u003d new double[repeatChunk];\r\n                // Timed block.\r\n                final long start \u003d System.nanoTime();\r\n                for (int i \u003d 0; i \u003c repeatChunk; i++) {\r\n                    result[i] \u003d r.call().doubleValue();\r\n                }\r\n                final long stop \u003d System.nanoTime();\r\n                // Collect run time.\r\n                timesAndResults[j][k][0] \u003d (stop - start) * NANO_TO_MILLI;\r\n                // Keep track of a randomly selected result.\r\n                timesAndResults[j][k][1] \u003d result[rng.nextInt(repeatChunk)];\r\n            }\r\n        }\r\n    } catch (Exception e) {\r\n        // Abort benchmarking if codes throw exceptions.\r\n        throw new MathIllegalStateException(LocalizedFormats.SIMPLE_MESSAGE, e.getMessage());\r\n    }\r\n    final double normFactor \u003d 1d / repeatChunk;\r\n    for (int j \u003d 0; j \u003c numMethods; j++) {\r\n        for (int k \u003d 0; k \u003c repeatStat; k++) {\r\n            timesAndResults[j][k][0] *\u003d normFactor;\r\n        }\r\n    }\r\n    return timesAndResults;\r\n}"
  },
  {
    "project": "commons-math",
    "className": "PerfTestUtils",
    "methodName": "timeAndReport",
    "complexity": 4,
    "loc": 68,
    "code": "/**\r\n * Timing and report (to standard output) the average time and standard\r\n * deviation of a single call.\r\n * The timing is performed by calling the\r\n * {@link #time(int,int,boolean,Callable[]) time} method.\r\n *\r\n * @param title Title of the test (for the report).\r\n * @param maxNameWidth Maximum width of the first column of the report.\r\n * @param repeatChunk Each timing measurement will done done for that\r\n * number of repeats of the code.\r\n * @param repeatStat Timing will be averaged over that number of runs.\r\n * @param runGC Call {@code System.gc()} between each timed block. When\r\n * set to {@code true}, the test will run much slower.\r\n * @param methods Codes being timed.\r\n * @return for each of the given {@code methods}, a statistics of the\r\n * average times (in milliseconds) taken by a single call to the\r\n * {@code call} method (i.e. the time taken by each timed block divided\r\n * by {@code repeatChunk}).\r\n */\r\n@SuppressWarnings(\"boxing\")\r\npublic static StatisticalSummary[] timeAndReport(String title, int maxNameWidth, int repeatChunk, int repeatStat, boolean runGC, RunTest... methods) {\r\n    // Header format.\r\n    final String hFormat \u003d \"%s (calls per timed block: %d, timed blocks: %d, time unit: ms)\";\r\n    // TODO: user-defined parameter?\r\n    final boolean removePackageName \u003d false;\r\n    // Width of the longest name.\r\n    int nameLength \u003d 0;\r\n    for (RunTest m : methods) {\r\n        int len \u003d shorten(m.getName(), removePackageName).length();\r\n        if (len \u003e nameLength) {\r\n            nameLength \u003d len;\r\n        }\r\n    }\r\n    final int actualNameLength \u003d nameLength \u003c maxNameWidth ? nameLength : maxNameWidth;\r\n    final String nameLengthFormat \u003d \"%\" + actualNameLength + \"s\";\r\n    // Column format.\r\n    final String cFormat \u003d nameLengthFormat + \" %9s %7s %10s %5s %4s %10s\";\r\n    // Result format.\r\n    final String format \u003d nameLengthFormat + \" %.3e %.1e %.4e %.3f %.2f %.4e\";\r\n    System.out.println(String.format(hFormat, title, repeatChunk, repeatStat));\r\n    System.out.println(String.format(cFormat, \"name\", \"time/call\", \"std dev\", \"total time\", \"ratio\", \"cv\", \"difference\"));\r\n    final StatisticalSummary[] time \u003d time(repeatChunk, repeatStat, runGC, methods);\r\n    final double refSum \u003d time[0].getSum() * repeatChunk;\r\n    for (int i \u003d 0, max \u003d time.length; i \u003c max; i++) {\r\n        final StatisticalSummary s \u003d time[i];\r\n        final double sum \u003d s.getSum() * repeatChunk;\r\n        final double mean \u003d s.getMean();\r\n        final double sigma \u003d s.getStandardDeviation();\r\n        System.out.println(String.format(format, truncate(shorten(methods[i].getName(), removePackageName), actualNameLength, ELLIPSIS), mean, sigma, sum, sum / refSum, sigma / mean, sum - refSum));\r\n    }\r\n    return time;\r\n}"
  }
]