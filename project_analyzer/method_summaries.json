[
  {
    "project": "commons-cli",
    "className": "DefaultParser",
    "methodName": "handleProperties",
    "complexity": 12,
    "loc": 30,
    "code": "/**\r\n * Sets the values of Options using the values in {@code properties}.\r\n *\r\n * @param properties The value properties to be processed.\r\n */\r\nprivate void handleProperties(final Properties properties) throws ParseException {\r\n    if (properties == null) {\r\n        return;\r\n    }\r\n    for (final Enumeration<?> e = properties.propertyNames(); e.hasMoreElements(); ) {\r\n        final String option = e.nextElement().toString();\r\n        final Option opt = options.getOption(option);\r\n        if (opt == null) {\r\n            throw new UnrecognizedOptionException(\"Default option wasn't defined\", option);\r\n        }\r\n        // if the option is part of a group, check if another option of the group has been selected\r\n        final OptionGroup group = options.getOptionGroup(opt);\r\n        final boolean selected = group != null && group.isSelected();\r\n        if (!cmd.hasOption(option) && !selected) {\r\n            // get the value from the properties\r\n            final String value = properties.getProperty(option);\r\n            if (opt.hasArg()) {\r\n                if (Util.isEmpty(opt.getValues())) {\r\n                    opt.processValue(stripLeadingAndTrailingQuotesDefaultOff(value));\r\n                }\r\n            } else if (!(\"yes\".equalsIgnoreCase(value) || \"true\".equalsIgnoreCase(value) || \"1\".equalsIgnoreCase(value))) {\r\n                // if the value is not yes, true or 1 then don't add the option to the CommandLine\r\n                continue;\r\n            }\r\n            handleOption(opt);\r\n            currentOption = null;\r\n        }\r\n    }\r\n}",
    "summary": "该方法用于处理传入的属性集合中的选项，根据选项定义和命令行参数情况，判断是否处理其对应值并执行相应操作。"
  },
  {
    "project": "commons-cli",
    "className": "DefaultParser",
    "methodName": "handleShortAndLongOption",
    "complexity": 13,
    "loc": 62,
    "code": "/**\r\n * Handles the following tokens:\r\n *\r\n * -S -SV -S V -S=V -S1S2 -S1S2 V -SV1=V2\r\n *\r\n * -L -LV -L V -L=V -l\r\n *\r\n * @param hyphenToken the command line token to handle\r\n */\r\nprivate void handleShortAndLongOption(final String hyphenToken) throws ParseException {\r\n    final String token = Util.stripLeadingHyphens(hyphenToken);\r\n    final int pos = indexOfEqual(token);\r\n    if (token.length() == 1) {\r\n        // -S\r\n        if (options.hasShortOption(token)) {\r\n            handleOption(options.getOption(token));\r\n        } else {\r\n            handleUnknownToken(hyphenToken);\r\n        }\r\n    } else if (pos == -1) {\r\n        // no equal sign found (-xxx)\r\n        if (options.hasShortOption(token)) {\r\n            handleOption(options.getOption(token));\r\n        } else if (!getMatchingLongOptions(token).isEmpty()) {\r\n            // -L or -l\r\n            handleLongOptionWithoutEqual(hyphenToken);\r\n        } else {\r\n            // look for a long prefix (-Xmx512m)\r\n            final String opt = getLongPrefix(token);\r\n            if (opt != null && options.getOption(opt).acceptsArg()) {\r\n                handleOption(options.getOption(opt));\r\n                currentOption.processValue(stripLeadingAndTrailingQuotesDefaultOff(token.substring(opt.length())));\r\n                currentOption = null;\r\n            } else if (isJavaProperty(token)) {\r\n                // -SV1 (-Dflag)\r\n                handleOption(options.getOption(token.substring(0, 1)));\r\n                currentOption.processValue(stripLeadingAndTrailingQuotesDefaultOff(token.substring(1)));\r\n                currentOption = null;\r\n            } else {\r\n                // -S1S2S3 or -S1S2V\r\n                handleConcatenatedOptions(hyphenToken);\r\n            }\r\n        }\r\n    } else {\r\n        // equal sign found (-xxx=yyy)\r\n        final String opt = token.substring(0, pos);\r\n        final String value = token.substring(pos + 1);\r\n        if (opt.length() == 1) {\r\n            // -S=V\r\n            final Option option = options.getOption(opt);\r\n            if (option != null && option.acceptsArg()) {\r\n                handleOption(option);\r\n                currentOption.processValue(value);\r\n                currentOption = null;\r\n            } else {\r\n                handleUnknownToken(hyphenToken);\r\n            }\r\n        } else if (isJavaProperty(opt)) {\r\n            // -SV1=V2 (-Dkey=value)\r\n            handleOption(options.getOption(opt.substring(0, 1)));\r\n            currentOption.processValue(opt.substring(1));\r\n            currentOption.processValue(value);\r\n            currentOption = null;\r\n        } else {\r\n            // -L=V or -l=V\r\n            handleLongOptionWithEqual(hyphenToken);\r\n        }\r\n    }\r\n}",
    "summary": "该方法处理命令行中的短选项（如 -S）、长选项（如 -L）及其带值的解析（如 -S=V）和拼接选项（如 -S1S2）的语法，根据不同格式提取并处理对应的选项参数。"
  },
  {
    "project": "commons-cli",
    "className": "DefaultParser",
    "methodName": "handleToken",
    "complexity": 12,
    "loc": 21,
    "code": "/**\r\n * Handles any command line token.\r\n *\r\n * @param token the command line token to handle\r\n * @throws ParseException\r\n */\r\nprivate void handleToken(final String token) throws ParseException {\r\n    if (token != null) {\r\n        currentToken = token;\r\n        if (skipParsing) {\r\n            cmd.addArg(token);\r\n        } else if (\"--\".equals(token)) {\r\n            skipParsing = true;\r\n        } else if (currentOption != null && currentOption.acceptsArg() && isArgument(token)) {\r\n            currentOption.processValue(stripLeadingAndTrailingQuotesDefaultOn(token));\r\n        } else if (token.startsWith(\"--\")) {\r\n            handleLongOption(token);\r\n        } else if (token.startsWith(\"-\") && !\"-\".equals(token)) {\r\n            handleShortAndLongOption(token);\r\n        } else {\r\n            handleUnknownToken(token);\r\n        }\r\n        if (currentOption != null && !currentOption.acceptsArg()) {\r\n            currentOption = null;\r\n        }\r\n    }\r\n}",
    "summary": "该方法用于处理命令行中的每个token，根据其类型解析选项、参数或未知项，并根据情况控制是否跳过后续的解析。"
  },
  {
    "project": "commons-cli",
    "className": "GnuParser",
    "methodName": "flatten",
    "complexity": 12,
    "loc": 45,
    "code": "/**\r\n * This flatten method does so using the following rules:\r\n * <ol>\r\n * <li>If an {@link Option} exists for the first character of the {@code arguments} entry <strong>AND</strong> an\r\n * {@link Option} does not exist for the whole {@code argument} then add the first character as an option to the\r\n * processed tokens list for example \"-D\" and add the rest of the entry to the also.</li>\r\n * <li>Otherwise just add the token to the processed tokens list.</li>\r\n * </ol>\r\n *\r\n * @param options The Options to parse the arguments by.\r\n * @param arguments The arguments that have to be flattened.\r\n * @param stopAtNonOption specifies whether to stop flattening when a non option has been encountered\r\n * @return a String array of the flattened arguments\r\n */\r\n@Override\r\nprotected String[] flatten(final Options options, final String[] arguments, final boolean stopAtNonOption) {\r\n    final List<String> tokens = new ArrayList<>();\r\n    boolean eatTheRest = false;\r\n    for (int i = 0; i < arguments.length; i++) {\r\n        final String arg = arguments[i];\r\n        if (arg != null) {\r\n            if (\"--\".equals(arg)) {\r\n                eatTheRest = true;\r\n                tokens.add(\"--\");\r\n            } else if (\"-\".equals(arg)) {\r\n                tokens.add(\"-\");\r\n            } else if (arg.startsWith(\"-\")) {\r\n                final String opt = Util.stripLeadingHyphens(arg);\r\n                if (options.hasOption(opt)) {\r\n                    tokens.add(arg);\r\n                } else {\r\n                    final int equalPos = DefaultParser.indexOfEqual(opt);\r\n                    if (equalPos != -1 && options.hasOption(opt.substring(0, equalPos))) {\r\n                        // the format is --foo=value or -foo=value\r\n                        // --foo\r\n                        tokens.add(arg.substring(0, arg.indexOf(Char.EQUAL)));\r\n                        // value\r\n                        tokens.add(arg.substring(arg.indexOf(Char.EQUAL) + 1));\r\n                    } else if (options.hasOption(arg.substring(0, 2))) {\r\n                        // the format is a special properties option (-Dproperty=value)\r\n                        // -D\r\n                        tokens.add(arg.substring(0, 2));\r\n                        // property=value\r\n                        tokens.add(arg.substring(2));\r\n                    } else {\r\n                        eatTheRest = stopAtNonOption;\r\n                        tokens.add(arg);\r\n                    }\r\n                }\r\n            } else {\r\n                tokens.add(arg);\r\n            }\r\n            if (eatTheRest) {\r\n                for (i++; i < arguments.length; i++) {\r\n                    // NOPMD\r\n                    tokens.add(arguments[i]);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return tokens.toArray(Util.EMPTY_STRING_ARRAY);\r\n}",
    "summary": "该方法用于将命令行参数数组进行扁平化处理，将选项和非选项分开，并根据规则拆分选项及其值，同时在遇到`--`或指定停止条件时将后续参数视为非选项添加到结果中。"
  },
  {
    "project": "commons-cli",
    "className": "TextHelpAppendable",
    "methodName": "adjustTableFormat",
    "complexity": 13,
    "loc": 51,
    "code": "/**\r\n * Adjusts the table format.\r\n * <p>\r\n * Given the width of the page and the size of the table attempt to resize the columns to fit the page width if necessary. Adjustments are made as follows:\r\n * </p>\r\n * <ul>\r\n * <li>The minimum size for a column may not be smaller than the length of the column header</li>\r\n * <li>The maximum size is set to the maximum of the length of the header or the longest line length.</li>\r\n * <li>If the total size of the columns is greater than the page wight, adjust the size of VARIABLE columns to attempt reduce the width to the the maximum\r\n * size.\r\n * </ul>\r\n * <p>\r\n * Note: it is possible for the size of the columns to exceed the declared page width. In this case the table will extend beyond the desired page width.\r\n * </p>\r\n *\r\n * @param table the table to adjust.\r\n * @return a new TableDefinition with adjusted values.\r\n */\r\nprotected TableDefinition adjustTableFormat(final TableDefinition table) {\r\n    final List<TextStyle.Builder> styleBuilders = new ArrayList<>();\r\n    for (int i = 0; i < table.columnTextStyles().size(); i++) {\r\n        final TextStyle style = table.columnTextStyles().get(i);\r\n        final TextStyle.Builder builder = TextStyle.builder().setTextStyle(style);\r\n        styleBuilders.add(builder);\r\n        final String header = table.headers().get(i);\r\n        if (style.getMaxWidth() < header.length() || style.getMaxWidth() == TextStyle.UNSET_MAX_WIDTH) {\r\n            builder.setMaxWidth(header.length());\r\n        }\r\n        if (style.getMinWidth() < header.length()) {\r\n            builder.setMinWidth(header.length());\r\n        }\r\n        for (final List<String> row : table.rows()) {\r\n            final String cell = row.get(i);\r\n            if (cell.length() > builder.getMaxWidth()) {\r\n                builder.setMaxWidth(cell.length());\r\n            }\r\n        }\r\n    }\r\n    // calculate the total width.\r\n    int calcWidth = 0;\r\n    int adjustedMaxWidth = textStyleBuilder.getMaxWidth();\r\n    for (final TextStyle.Builder builder : styleBuilders) {\r\n        adjustedMaxWidth -= builder.getLeftPad();\r\n        if (builder.isScalable()) {\r\n            calcWidth += builder.getMaxWidth();\r\n        } else {\r\n            adjustedMaxWidth -= builder.getMaxWidth();\r\n        }\r\n    }\r\n    // rescale if necessary\r\n    if (calcWidth > adjustedMaxWidth) {\r\n        final double fraction = adjustedMaxWidth * 1.0 / calcWidth;\r\n        for (int i = 0; i < styleBuilders.size(); i++) {\r\n            final TextStyle.Builder builder = styleBuilders.get(i);\r\n            if (builder.isScalable()) {\r\n                // resize and remove the padding from the maxWidth calculation.\r\n                styleBuilders.set(i, resize(builder, fraction));\r\n            }\r\n        }\r\n    }\r\n    // regenerate the styles\r\n    final List<TextStyle> styles = new ArrayList<>();\r\n    for (final TextStyle.Builder builder : styleBuilders) {\r\n        // adjust by removing the padding as it was not accounted for above.\r\n        styles.add(builder.get());\r\n    }\r\n    return TableDefinition.from(table.caption(), styles, table.headers(), table.rows());\r\n}",
    "summary": "该方法调整表格列宽以适应页面宽度，确保列宽不小于表头长度且不超过最长行长度，并在总宽度超出时缩放可调整的列。"
  },
  {
    "project": "commons-cli",
    "className": "TextStyle",
    "methodName": "pad",
    "complexity": 11,
    "loc": 46,
    "code": "/**\r\n * Pads a string to the maximum width or optionally to the maximum width - indent.\r\n * <ul>\r\n * <li>Returns the string unchanged if it is longer than the specified length.</li>\r\n * <li>Will add the padding based on the alignment.</li>\r\n * </ul>\r\n *\r\n * @param addIndent if {@code true} account for the indent when padding the string.\r\n * @param text      the text to pad.\r\n * @return the padded string.\r\n */\r\npublic CharSequence pad(final boolean addIndent, final CharSequence text) {\r\n    if (text.length() >= maxWidth) {\r\n        return text;\r\n    }\r\n    String indentPad;\r\n    String rest;\r\n    final StringBuilder sb = new StringBuilder();\r\n    switch(alignment) {\r\n        case CENTER:\r\n            int padLen;\r\n            if (maxWidth == UNSET_MAX_WIDTH) {\r\n                padLen = addIndent ? indent : 0;\r\n            } else {\r\n                padLen = maxWidth - text.length();\r\n            }\r\n            final int left = padLen / 2;\r\n            indentPad = Util.repeatSpace(left);\r\n            rest = Util.repeatSpace(padLen - left);\r\n            sb.append(indentPad).append(text).append(rest);\r\n            break;\r\n        case LEFT:\r\n        case RIGHT:\r\n        default:\r\n            // default should never happen. It is here to keep code coverage happy.\r\n            if (maxWidth == UNSET_MAX_WIDTH) {\r\n                indentPad = addIndent ? Util.repeatSpace(indent) : \"\";\r\n                rest = \"\";\r\n            } else {\r\n                int restLen = maxWidth - text.length();\r\n                if (addIndent && restLen > indent) {\r\n                    indentPad = Util.repeatSpace(indent);\r\n                    restLen -= indent;\r\n                } else {\r\n                    indentPad = \"\";\r\n                }\r\n                rest = Util.repeatSpace(restLen);\r\n            }\r\n            if (alignment == Alignment.LEFT) {\r\n                sb.append(indentPad).append(text).append(rest);\r\n            } else {\r\n                sb.append(indentPad).append(rest).append(text);\r\n            }\r\n            break;\r\n    }\r\n    return sb.toString();\r\n}",
    "summary": "该方法根据指定的对齐方式和是否考虑缩进，将输入字符串填充到最大宽度，若原字符串长度超过则直接返回。"
  },
  {
    "project": "commons-cli",
    "className": "HelpFormatter",
    "methodName": "appendOptions",
    "complexity": 16,
    "loc": 72,
    "code": "/**\r\n * Renders the specified Options and return the rendered Options in a StringBuffer.\r\n *\r\n * @param sb The StringBuffer to place the rendered Options into.\r\n * @param width The number of characters to display per line\r\n * @param options The command line Options\r\n * @param leftPad the number of characters of padding to be prefixed to each line\r\n * @param descPad the number of characters of padding to be prefixed to each description line\r\n * @return the StringBuffer with the rendered Options contents.\r\n * @throws IOException if an I/O error occurs.\r\n */\r\n<A extends Appendable> A appendOptions(final A sb, final int width, final Options options, final int leftPad, final int descPad) throws IOException {\r\n    final String lpad = createPadding(leftPad);\r\n    final String dpad = createPadding(descPad);\r\n    // first create list containing only <lpad>-a,--aaa where\r\n    // -a is opt and --aaa is long opt; in parallel look for\r\n    // the longest opt string this list will be then used to\r\n    // sort options ascending\r\n    int max = 0;\r\n    final int maxSince = showSince ? determineMaxSinceLength(options) + leftPad : 0;\r\n    final List<StringBuilder> prefixList = new ArrayList<>();\r\n    final List<Option> optList = options.helpOptions();\r\n    if (getOptionComparator() != null) {\r\n        Collections.sort(optList, getOptionComparator());\r\n    }\r\n    for (final Option option : optList) {\r\n        final StringBuilder optBuf = new StringBuilder();\r\n        if (option.getOpt() == null) {\r\n            optBuf.append(lpad).append(\"   \").append(getLongOptPrefix()).append(option.getLongOpt());\r\n        } else {\r\n            optBuf.append(lpad).append(getOptPrefix()).append(option.getOpt());\r\n            if (option.hasLongOpt()) {\r\n                optBuf.append(',').append(getLongOptPrefix()).append(option.getLongOpt());\r\n            }\r\n        }\r\n        if (option.hasArg()) {\r\n            final String argName = option.getArgName();\r\n            if (argName != null && argName.isEmpty()) {\r\n                // if the option has a blank argname\r\n                optBuf.append(' ');\r\n            } else {\r\n                optBuf.append(option.hasLongOpt() ? longOptSeparator : \" \");\r\n                optBuf.append(\"<\").append(argName != null ? option.getArgName() : getArgName()).append(\">\");\r\n            }\r\n        }\r\n        prefixList.add(optBuf);\r\n        max = Math.max(optBuf.length() + maxSince, max);\r\n    }\r\n    final int nextLineTabStop = max + descPad;\r\n    if (showSince) {\r\n        final StringBuilder optHeader = new StringBuilder(HEADER_OPTIONS).append(createPadding(max - maxSince - HEADER_OPTIONS.length() + leftPad)).append(HEADER_SINCE);\r\n        optHeader.append(createPadding(max - optHeader.length())).append(lpad).append(HEADER_DESCRIPTION);\r\n        appendWrappedText(sb, width, nextLineTabStop, optHeader.toString());\r\n        sb.append(getNewLine());\r\n    }\r\n    int x = 0;\r\n    for (final Iterator<Option> it = optList.iterator(); it.hasNext(); ) {\r\n        final Option option = it.next();\r\n        final StringBuilder optBuf = new StringBuilder(prefixList.get(x++).toString());\r\n        if (optBuf.length() < max) {\r\n            optBuf.append(createPadding(max - maxSince - optBuf.length()));\r\n            if (showSince) {\r\n                optBuf.append(lpad).append(option.getSince() == null ? \"-\" : option.getSince());\r\n            }\r\n            optBuf.append(createPadding(max - optBuf.length()));\r\n        }\r\n        optBuf.append(dpad);\r\n        if (deprecatedFormatFunction != null && option.isDeprecated()) {\r\n            optBuf.append(deprecatedFormatFunction.apply(option).trim());\r\n        } else if (option.getDescription() != null) {\r\n            optBuf.append(option.getDescription());\r\n        }\r\n        appendWrappedText(sb, width, nextLineTabStop, optBuf.toString());\r\n        if (it.hasNext()) {\r\n            sb.append(getNewLine());\r\n        }\r\n    }\r\n    return sb;\r\n}",
    "summary": "该方法将命令行选项按照指定宽度和填充格式渲染到缓冲区，包括选项标识、描述及版本信息，并处理换行和对齐。"
  },
  {
    "project": "commons-cli",
    "className": "HelpFormatter",
    "methodName": "findWrapPos",
    "complexity": 11,
    "loc": 28,
    "code": "/**\r\n * Finds the next text wrap position after {@code startPos} for the text in {@code text} with the column width\r\n * {@code width}. The wrap point is the last position before startPos+width having a whitespace character (space,\r\n * \\n, \\r). If there is no whitespace character before startPos+width, it will return startPos+width.\r\n *\r\n * @param text The text being searched for the wrap position\r\n * @param width width of the wrapped text\r\n * @param startPos position from which to start the lookup whitespace character\r\n * @return position on which the text must be wrapped or -1 if the wrap position is at the end of the text\r\n */\r\nprotected int findWrapPos(final String text, final int width, final int startPos) {\r\n    // the line ends before the max wrap pos or a new line char found\r\n    int pos = text.indexOf(Char.LF, startPos);\r\n    if (pos != -1 && pos <= width) {\r\n        return pos + 1;\r\n    }\r\n    pos = text.indexOf(Char.TAB, startPos);\r\n    if (pos != -1 && pos <= width) {\r\n        return pos + 1;\r\n    }\r\n    if (startPos + width >= text.length()) {\r\n        return -1;\r\n    }\r\n    // look for the last whitespace character before startPos+width\r\n    for (pos = startPos + width; pos >= startPos; --pos) {\r\n        final char c = text.charAt(pos);\r\n        if (c == Char.SP || c == Char.LF || c == Char.CR) {\r\n            break;\r\n        }\r\n    }\r\n    // if we found it - just return\r\n    if (pos > startPos) {\r\n        return pos;\r\n    }\r\n    // if we didn't find one, simply chop at startPos+width\r\n    pos = startPos + width;\r\n    return pos == text.length() ? -1 : pos;\r\n}",
    "summary": "该方法在给定文本中从startPos开始，寻找在startPos+width范围内的最后一个空白字符位置作为换行点，若未找到则返回startPos+width，若超出文本长度则返回-1。"
  },
  {
    "project": "commons-cli",
    "className": "Parser",
    "methodName": "parse",
    "complexity": 15,
    "loc": 61,
    "code": "/**\r\n * Parse the arguments according to the specified options and properties.\r\n *\r\n * @param options the specified Options\r\n * @param arguments the command line arguments\r\n * @param properties command line option name-value pairs\r\n * @param stopAtNonOption if {@code true} an unrecognized argument stops the parsing and the remaining arguments\r\n *        are added to the {@link CommandLine}s args list. If {@code false} an unrecognized argument triggers a\r\n *        ParseException.\r\n * @return the list of atomic option and value tokens\r\n * @throws ParseException if there are any problems encountered while parsing the command line tokens.\r\n * @since 1.1\r\n */\r\npublic CommandLine parse(final Options options, final String[] arguments, final Properties properties, final boolean stopAtNonOption) throws ParseException {\r\n    // clear out the data in options in case it's been used before (CLI-71)\r\n    for (final Option opt : options.helpOptions()) {\r\n        opt.clearValues();\r\n    }\r\n    // clear the data from the groups\r\n    for (final OptionGroup group : options.getOptionGroups()) {\r\n        group.setSelected(null);\r\n    }\r\n    // initialize members\r\n    setOptions(options);\r\n    cmd = CommandLine.builder().get();\r\n    boolean eatTheRest = false;\r\n    final List<String> tokenList = Arrays.asList(flatten(getOptions(), arguments == null ? new String[0] : arguments, stopAtNonOption));\r\n    final ListIterator<String> iterator = tokenList.listIterator();\r\n    // process each flattened token\r\n    while (iterator.hasNext()) {\r\n        final String token = iterator.next();\r\n        if (token != null) {\r\n            // the value is the double-dash\r\n            if (\"--\".equals(token)) {\r\n                eatTheRest = true;\r\n            } else if (\"-\".equals(token)) {\r\n                // the value is a single dash\r\n                if (stopAtNonOption) {\r\n                    eatTheRest = true;\r\n                } else {\r\n                    cmd.addArg(token);\r\n                }\r\n            } else if (token.startsWith(\"-\")) {\r\n                // the value is an option\r\n                if (stopAtNonOption && !getOptions().hasOption(token)) {\r\n                    eatTheRest = true;\r\n                    cmd.addArg(token);\r\n                } else {\r\n                    processOption(token, iterator);\r\n                }\r\n            } else {\r\n                // the value is an argument\r\n                cmd.addArg(token);\r\n                if (stopAtNonOption) {\r\n                    eatTheRest = true;\r\n                }\r\n            }\r\n            // eat the remaining tokens\r\n            if (eatTheRest) {\r\n                while (iterator.hasNext()) {\r\n                    final String str = iterator.next();\r\n                    // ensure only one double-dash is added\r\n                    if (!\"--\".equals(str)) {\r\n                        cmd.addArg(str);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    processProperties(properties);\r\n    checkRequiredOptions();\r\n    return cmd;\r\n}",
    "summary": "该方法用于解析命令行参数，根据指定的选项和属性处理各参数，遇非选项时根据`stopAtNonOption`设置决定是否停止解析或抛出异常。"
  },
  {
    "project": "commons-cli",
    "className": "Parser",
    "methodName": "processProperties",
    "complexity": 12,
    "loc": 34,
    "code": "/**\r\n * Sets the values of Options using the values in {@code properties}.\r\n *\r\n * @param properties The value properties to be processed.\r\n * @throws ParseException if there are any problems encountered while processing the properties.\r\n */\r\nprotected void processProperties(final Properties properties) throws ParseException {\r\n    if (properties == null) {\r\n        return;\r\n    }\r\n    for (final Enumeration<?> e = properties.propertyNames(); e.hasMoreElements(); ) {\r\n        final String option = e.nextElement().toString();\r\n        final Option opt = options.getOption(option);\r\n        if (opt == null) {\r\n            throw new UnrecognizedOptionException(\"Default option wasn't defined\", option);\r\n        }\r\n        // if the option is part of a group, check if another option of the group has been selected\r\n        final OptionGroup group = options.getOptionGroup(opt);\r\n        final boolean selected = group != null && group.isSelected();\r\n        if (!cmd.hasOption(option) && !selected) {\r\n            // get the value from the properties instance\r\n            final String value = properties.getProperty(option);\r\n            if (opt.hasArg()) {\r\n                if (Util.isEmpty(opt.getValues())) {\r\n                    try {\r\n                        opt.processValue(value);\r\n                    } catch (final RuntimeException exp) {\r\n                        // NOPMD\r\n                        // if we cannot add the value don't worry about it\r\n                    }\r\n                }\r\n            } else if (!(\"yes\".equalsIgnoreCase(value) || \"true\".equalsIgnoreCase(value) || \"1\".equalsIgnoreCase(value))) {\r\n                // if the value is not yes, true or 1 then don't add the\r\n                // option to the CommandLine\r\n                continue;\r\n            }\r\n            cmd.addOption(opt);\r\n            updateRequiredOptions(opt);\r\n        }\r\n    }\r\n}",
    "summary": "该方法遍历传入的属性，将其中符合要求的选项转换为命令行参数，处理相关逻辑并可能抛出异常或跳过无效选项。"
  },
  {
    "project": "commons-cli",
    "className": "PatternOptionBuilder",
    "methodName": "parsePattern",
    "complexity": 6,
    "loc": 51,
    "code": "/**\r\n * Returns the {@link Options} instance represented by {@code pattern}.\r\n *\r\n * @param pattern the pattern string\r\n * @return The {@link Options} instance\r\n */\r\npublic static Options parsePattern(final String pattern) {\r\n    char opt = Char.SP;\r\n    boolean required = false;\r\n    Class<?> type = null;\r\n    Converter<?, ?> converter = Converter.DEFAULT;\r\n    final Options options = new Options();\r\n    for (int i = 0; i < pattern.length(); i++) {\r\n        final char ch = pattern.charAt(i);\r\n        // a value code comes after an option and specifies\r\n        // details about it\r\n        if (!isValueCode(ch)) {\r\n            if (opt != Char.SP) {\r\n                // @formatter:off\r\n                final Option option = Option.builder(String.valueOf(opt)).hasArg(type != null).required(required).type(type).converter(converter).build();\r\n                // @formatter:on\r\n                // we have a previous one to deal with\r\n                options.addOption(option);\r\n                required = false;\r\n                type = null;\r\n                converter = Converter.DEFAULT;\r\n            }\r\n            opt = ch;\r\n        } else if (ch == '!') {\r\n            required = true;\r\n        } else {\r\n            type = getValueType(ch);\r\n            final Map<Class<?>, Converter<?, ? extends Throwable>> map = TypeHandler.createDefaultMap();\r\n            // Backward compatibility (probably).\r\n            map.put(FILES_VALUE, unsupported());\r\n            converter = new TypeHandler(map).getConverter(getValueType(ch));\r\n        }\r\n    }\r\n    if (opt != Char.SP) {\r\n        final Option option = Option.builder(String.valueOf(opt)).hasArg(type != null).required(required).type(type).build();\r\n        // we have a final one to deal with\r\n        options.addOption(option);\r\n    }\r\n    return options;\r\n}",
    "summary": "该方法将输入的模式字符串解析为Options实例，每个字符对应一个选项，并设置其是否必填、类型和转换器等属性。"
  },
  {
    "project": "commons-cli",
    "className": "PosixParser",
    "methodName": "flatten",
    "complexity": 14,
    "loc": 56,
    "code": "/**\r\n * <p>\r\n * An implementation of {@link Parser}'s abstract {@link Parser#flatten(Options,String[],boolean) flatten} method.\r\n * </p>\r\n *\r\n * <p>\r\n * The following are the rules used by this flatten method.\r\n * </p>\r\n * <ol>\r\n * <li>if {@code stopAtNonOption} is <strong>true</strong> then do not burst anymore of {@code arguments} entries, just\r\n * add each successive entry without further processing. Otherwise, ignore {@code stopAtNonOption}.</li>\r\n * <li>if the current {@code arguments} entry is \"<strong>--</strong>\" just add the entry to the list of processed\r\n * tokens</li>\r\n * <li>if the current {@code arguments} entry is \"<strong>-</strong>\" just add the entry to the list of processed tokens</li>\r\n * <li>if the current {@code arguments} entry is two characters in length and the first character is \"<strong>-</strong>\"\r\n * then check if this is a valid {@link Option} id. If it is a valid id, then add the entry to the list of processed\r\n * tokens and set the current {@link Option} member. If it is not a valid id and {@code stopAtNonOption} is true,\r\n * then the remaining entries are copied to the list of processed tokens. Otherwise, the current entry is ignored.</li>\r\n * <li>if the current {@code arguments} entry is more than two characters in length and the first character is\r\n * \"<strong>-</strong>\" then we need to burst the entry to determine its constituents. For more information on the bursting\r\n * algorithm see {@link PosixParser#burstToken(String, boolean) burstToken}.</li>\r\n * <li>if the current {@code arguments} entry is not handled by any of the previous rules, then the entry is added\r\n * to the list of processed tokens.</li>\r\n * </ol>\r\n *\r\n * @param options The command line {@link Options}\r\n * @param arguments The command line arguments to be parsed\r\n * @param stopAtNonOption Specifies whether to stop flattening when an non option is found.\r\n * @return The flattened {@code arguments} String array.\r\n */\r\n@Override\r\nprotected String[] flatten(final Options options, final String[] arguments, final boolean stopAtNonOption) throws ParseException {\r\n    init();\r\n    this.options = options;\r\n    // an iterator for the command line tokens\r\n    final Iterator<String> iter = Arrays.asList(arguments).iterator();\r\n    // process each command line token\r\n    while (iter.hasNext()) {\r\n        // get the next command line token\r\n        final String token = iter.next();\r\n        if (token != null) {\r\n            // single or double hyphen\r\n            if (\"-\".equals(token) || \"--\".equals(token)) {\r\n                tokens.add(token);\r\n            } else if (token.startsWith(\"--\")) {\r\n                // handle long option --foo or --foo=bar\r\n                final int pos = DefaultParser.indexOfEqual(token);\r\n                // --foo\r\n                final String opt = pos == -1 ? token : token.substring(0, pos);\r\n                final List<String> matchingOpts = options.getMatchingOptions(opt);\r\n                if (matchingOpts.isEmpty()) {\r\n                    processNonOptionToken(token, stopAtNonOption);\r\n                } else if (matchingOpts.size() > 1) {\r\n                    throw new AmbiguousOptionException(opt, matchingOpts);\r\n                } else {\r\n                    currentOption = options.getOption(matchingOpts.get(0));\r\n                    tokens.add(\"--\" + currentOption.getLongOpt());\r\n                    if (pos != -1) {\r\n                        tokens.add(token.substring(pos + 1));\r\n                    }\r\n                }\r\n            } else if (token.startsWith(\"-\")) {\r\n                if (token.length() == 2 || options.hasOption(token)) {\r\n                    processOptionToken(token, stopAtNonOption);\r\n                } else if (!options.getMatchingOptions(token).isEmpty()) {\r\n                    final List<String> matchingOpts = options.getMatchingOptions(token);\r\n                    if (matchingOpts.size() > 1) {\r\n                        throw new AmbiguousOptionException(token, matchingOpts);\r\n                    }\r\n                    final Option opt = options.getOption(matchingOpts.get(0));\r\n                    processOptionToken(\"-\" + opt.getLongOpt(), stopAtNonOption);\r\n                } else // requires bursting\r\n                {\r\n                    burstToken(token, stopAtNonOption);\r\n                }\r\n            } else {\r\n                processNonOptionToken(token, stopAtNonOption);\r\n            }\r\n        }\r\n        gobble(iter);\r\n    }\r\n    return tokens.toArray(Util.EMPTY_STRING_ARRAY);\r\n}",
    "summary": "该方法解析命令行参数，根据规则处理选项和非选项，并返回处理后的字符串数组。"
  },
  {
    "project": "commons-math",
    "className": "CannonballExample",
    "methodName": "cannonballTest",
    "complexity": 2,
    "loc": 137,
    "code": "public static void cannonballTest(Chart chart) {\r\n    // time interval for each iteration\r\n    final double dt = 0.1;\r\n    // the number of iterations to run\r\n    final int iterations = 144;\r\n    // measurement noise (m)\r\n    final double measurementNoise = 30;\r\n    // initial velocity of the cannonball\r\n    final double initialVelocity = 100;\r\n    // shooting angle\r\n    final double angle = 45;\r\n    // the cannonball itself\r\n    final Cannonball cannonball = new Cannonball(dt, angle, initialVelocity, measurementNoise, 1000);\r\n    // A = [ 1, dt, 0,  0 ]  =>  x(n+1) = x(n) + vx(n)\r\n    //     [ 0,  1, 0,  0 ]  => vx(n+1) =        vx(n)\r\n    //     [ 0,  0, 1, dt ]  =>  y(n+1) =              y(n) + vy(n)\r\n    //     [ 0,  0, 0,  1 ]  => vy(n+1) =                     vy(n)\r\n    final RealMatrix A = MatrixUtils.createRealMatrix(new double[][] { { 1, dt, 0, 0 }, { 0, 1, 0, 0 }, { 0, 0, 1, dt }, { 0, 0, 0, 1 } });\r\n    // The control vector, which adds acceleration to the kinematic equations.\r\n    // 0          =>  x(n+1) =  x(n+1)\r\n    // 0          => vx(n+1) = vx(n+1)\r\n    // -9.81*dt^2 =>  y(n+1) =  y(n+1) - 1/2 * 9.81 * dt^2\r\n    // -9.81*dt   => vy(n+1) = vy(n+1) - 9.81 * dt\r\n    final RealVector controlVector = MatrixUtils.createRealVector(new double[] { 0, 0, 0.5 * -9.81 * dt * dt, -9.81 * dt });\r\n    // The control matrix B only update y and vy, see control vector\r\n    final RealMatrix B = MatrixUtils.createRealMatrix(new double[][] { { 0, 0, 0, 0 }, { 0, 0, 0, 0 }, { 0, 0, 1, 0 }, { 0, 0, 0, 1 } });\r\n    // After state transition and control, here are the equations:\r\n    //\r\n    //  x(n+1) = x(n) + vx(n)\r\n    // vx(n+1) = vx(n)\r\n    //  y(n+1) = y(n) + vy(n) - 0.5 * 9.81 * dt^2\r\n    // vy(n+1) = vy(n) + -9.81 * dt\r\n    //\r\n    // Which, if you recall, are the equations of motion for a parabola.\r\n    // We only observe the x/y position of the cannonball\r\n    final RealMatrix H = MatrixUtils.createRealMatrix(new double[][] { { 1, 0, 0, 0 }, { 0, 0, 0, 0 }, { 0, 0, 1, 0 }, { 0, 0, 0, 0 } });\r\n    // This is our guess of the initial state.  I intentionally set the Y value\r\n    // wrong to illustrate how fast the Kalman filter will pick up on that.\r\n    final double speedX = cannonball.getXVelocity();\r\n    final double speedY = cannonball.getYVelocity();\r\n    final RealVector initialState = MatrixUtils.createRealVector(new double[] { 0, speedX, 100, speedY });\r\n    // The initial error covariance matrix, the variance = noise^2\r\n    final double var = measurementNoise * measurementNoise;\r\n    final RealMatrix initialErrorCovariance = MatrixUtils.createRealMatrix(new double[][] { { var, 0, 0, 0 }, { 0, 1e-3, 0, 0 }, { 0, 0, var, 0 }, { 0, 0, 0, 1e-3 } });\r\n    // we assume no process noise -> zero matrix\r\n    final RealMatrix Q = MatrixUtils.createRealMatrix(4, 4);\r\n    // the measurement covariance matrix\r\n    final RealMatrix R = MatrixUtils.createRealMatrix(new double[][] { { var, 0, 0, 0 }, { 0, 1e-3, 0, 0 }, { 0, 0, var, 0 }, { 0, 0, 0, 1e-3 } });\r\n    final ProcessModel pm = new DefaultProcessModel(A, B, Q, initialState, initialErrorCovariance);\r\n    final MeasurementModel mm = new DefaultMeasurementModel(H, R);\r\n    final KalmanFilter filter = new KalmanFilter(pm, mm);\r\n    final List<Number> realX = new ArrayList<>();\r\n    final List<Number> realY = new ArrayList<>();\r\n    final List<Number> measuredX = new ArrayList<>();\r\n    final List<Number> measuredY = new ArrayList<>();\r\n    final List<Number> kalmanX = new ArrayList<>();\r\n    final List<Number> kalmanY = new ArrayList<>();\r\n    for (int i = 0; i < iterations; i++) {\r\n        // get real location\r\n        realX.add(cannonball.getX());\r\n        realY.add(cannonball.getY());\r\n        // get measured location\r\n        final double mx = cannonball.getMeasuredX();\r\n        final double my = cannonball.getMeasuredY();\r\n        measuredX.add(mx);\r\n        measuredY.add(my);\r\n        // iterate the cannon simulation to the next timeslice.\r\n        cannonball.step();\r\n        final double[] state = filter.getStateEstimation();\r\n        kalmanX.add(state[0]);\r\n        kalmanY.add(state[2]);\r\n        // update the kalman filter with the measurements\r\n        filter.predict(controlVector);\r\n        filter.correct(new double[] { mx, 0, my, 0 });\r\n    }\r\n    chart.setXAxisTitle(\"Distance (m)\");\r\n    chart.setYAxisTitle(\"Height (m)\");\r\n    Series dataset = chart.addSeries(\"true\", realX, realY);\r\n    dataset.setMarker(SeriesMarker.NONE);\r\n    dataset = chart.addSeries(\"measured\", measuredX, measuredY);\r\n    dataset.setLineStyle(SeriesLineStyle.DOT_DOT);\r\n    dataset.setMarker(SeriesMarker.NONE);\r\n    dataset = chart.addSeries(\"kalman\", kalmanX, kalmanY);\r\n    dataset.setLineColor(Color.red);\r\n    dataset.setLineStyle(SeriesLineStyle.DASH_DASH);\r\n    dataset.setMarker(SeriesMarker.NONE);\r\n}",
    "summary": "该方法通过卡尔曼滤波估计炮弹的运动轨迹，对比真实位置、测量噪声干扰的位置和滤波后的估计值，并将结果可视化。"
  },
  {
    "project": "commons-math",
    "className": "ConstantVoltageExample",
    "methodName": "constantVoltageTest",
    "complexity": 2,
    "loc": 83,
    "code": "/**\r\n * constant voltage test\r\n */\r\npublic static void constantVoltageTest(Chart chart1, Chart chart2) {\r\n    final double voltage = 1.25d;\r\n    // measurement noise (V) - std dev\r\n    final double measurementNoise = 0.2d;\r\n    final double processNoise = 1e-5d;\r\n    final VoltMeter voltMeter = new VoltMeter(voltage, processNoise, measurementNoise, 2);\r\n    // the state transition matrix -> constant\r\n    final RealMatrix A = new Array2DRowRealMatrix(new double[] { 1d });\r\n    // the control matrix -> no control input\r\n    final RealMatrix B = new Array2DRowRealMatrix(new double[] { 0d });\r\n    // the measurement matrix -> we measure the voltage directly\r\n    final RealMatrix H = new Array2DRowRealMatrix(new double[] { 1d });\r\n    // the initial state vector -> slightly wrong\r\n    final RealVector x0 = new ArrayRealVector(new double[] { 1.45 });\r\n    // the process covariance matrix\r\n    final RealMatrix Q = new Array2DRowRealMatrix(new double[] { processNoise * processNoise });\r\n    // the initial error covariance -> assume a large error at the beginning\r\n    final RealMatrix P0 = new Array2DRowRealMatrix(new double[] { 0.1 });\r\n    // the measurement covariance matrix -> put the \"real\" variance\r\n    RealMatrix R = new Array2DRowRealMatrix(new double[] { measurementNoise * measurementNoise });\r\n    final ProcessModel pm = new DefaultProcessModel(A, B, Q, x0, P0);\r\n    final MeasurementModel mm = new DefaultMeasurementModel(H, R);\r\n    final KalmanFilter filter = new KalmanFilter(pm, mm);\r\n    final List<Number> xAxis = new ArrayList<>();\r\n    final List<Number> realVoltageSeries = new ArrayList<>();\r\n    final List<Number> measuredVoltageSeries = new ArrayList<>();\r\n    final List<Number> kalmanVoltageSeries = new ArrayList<>();\r\n    final List<Number> covSeries = new ArrayList<>();\r\n    for (int i = 0; i < 300; i++) {\r\n        xAxis.add(i);\r\n        voltMeter.step();\r\n        realVoltageSeries.add(voltMeter.getVoltage());\r\n        // get the measured voltage from the volt meter\r\n        final double measuredVoltage = voltMeter.getMeasuredVoltage();\r\n        measuredVoltageSeries.add(measuredVoltage);\r\n        kalmanVoltageSeries.add(filter.getStateEstimation()[0]);\r\n        covSeries.add(filter.getErrorCovariance()[0][0]);\r\n        filter.predict();\r\n        filter.correct(new double[] { measuredVoltage });\r\n    }\r\n    chart1.setYAxisTitle(\"Voltage\");\r\n    chart1.setXAxisTitle(\"Iteration\");\r\n    Series dataset = chart1.addSeries(\"real\", xAxis, realVoltageSeries);\r\n    dataset.setMarker(SeriesMarker.NONE);\r\n    dataset = chart1.addSeries(\"measured\", xAxis, measuredVoltageSeries);\r\n    dataset.setLineStyle(SeriesLineStyle.DOT_DOT);\r\n    dataset.setMarker(SeriesMarker.NONE);\r\n    dataset = chart1.addSeries(\"filtered\", xAxis, kalmanVoltageSeries);\r\n    dataset.setLineColor(Color.red);\r\n    dataset.setLineStyle(SeriesLineStyle.DASH_DASH);\r\n    dataset.setMarker(SeriesMarker.NONE);\r\n    // Error covariance chart\r\n    chart2.setYAxisTitle(\"(Voltage)²\");\r\n    chart2.setXAxisTitle(\"Iteration\");\r\n    dataset = chart2.addSeries(\"cov\", xAxis, covSeries);\r\n    dataset.setLineColor(Color.black);\r\n    dataset.setLineStyle(SeriesLineStyle.SOLID);\r\n    dataset.setMarker(SeriesMarker.NONE);\r\n}",
    "summary": "该方法使用卡尔曼滤波器对恒定电压进行估计，通过模拟测量噪声并处理数据，最终可视化真实电压、测量电压、滤波后电压及误差协方差的时序变化。"
  },
  {
    "project": "commons-math",
    "className": "JdkMathTestPerformance",
    "methodName": "testSimpleBenchmark",
    "complexity": 1,
    "loc": 494,
    "code": "@SuppressWarnings(\"boxing\")\r\nprivate static void testSimpleBenchmark() {\r\n    final String SM = \"StrictMath\";\r\n    final String M = \"Math\";\r\n    final String FM = \"JdkMath\";\r\n    final int maxWidth = 15;\r\n    final int numStat = 100;\r\n    final int numCall = RUNS / numStat;\r\n    final double x = Math.random();\r\n    final double y = Math.random();\r\n    PerfTestUtils.timeAndReport(\"log\", maxWidth, numCall, numStat, false, new PerfTestUtils.RunTest(SM) {\r\n\r\n        @Override\r\n        public Double call() throws Exception {\r\n            return StrictMath.log(x);\r\n        }\r\n    }, new PerfTestUtils.RunTest(M) {\r\n\r\n        @Override\r\n        public Double call() throws Exception {\r\n            return Math.log(x);\r\n        }\r\n    }, new PerfTestUtils.RunTest(FM) {\r\n\r\n        @Override\r\n        public Double call() throws Exception {\r\n            return JdkMath.log(x);\r\n        }\r\n    });\r\n    PerfTestUtils.timeAndReport(\"log10\", maxWidth, numCall, numStat, false, new PerfTestUtils.RunTest(SM) {\r\n\r\n        @Override\r\n        public Double call() throws Exception {\r\n            return StrictMath.log10(x);\r\n        }\r\n    }, new PerfTestUtils.RunTest(M) {\r\n\r\n        @Override\r\n        public Double call() throws Exception {\r\n            return Math.log10(x);\r\n        }\r\n    }, new PerfTestUtils.RunTest(FM) {\r\n\r\n        @Override\r\n        public Double call() throws Exception {\r\n            return JdkMath.log10(x);\r\n        }\r\n    });\r\n    PerfTestUtils.timeAndReport(\"log1p\", maxWidth, numCall, numStat, false, new PerfTestUtils.RunTest(SM) {\r\n\r\n        @Override\r\n        public Double call() throws Exception {\r\n            return StrictMath.log1p(x);\r\n        }\r\n    }, new PerfTestUtils.RunTest(M) {\r\n\r\n        @Override\r\n        public Double call() throws Exception {\r\n            return Math.log1p(x);\r\n        }\r\n    }, new PerfTestUtils.RunTest(FM) {\r\n\r\n        @Override\r\n        public Double call() throws Exception {\r\n            return JdkMath.log1p(x);\r\n        }\r\n    });\r\n    PerfTestUtils.timeAndReport(\"pow\", maxWidth, numCall, numStat, false, new PerfTestUtils.RunTest(SM) {\r\n\r\n        @Override\r\n        public Double call() throws Exception {\r\n            return StrictMath.pow(x, y);\r\n        }\r\n    }, new PerfTestUtils.RunTest(M) {\r\n\r\n        @Override\r\n        public Double call() throws Exception {\r\n            return Math.pow(x, y);\r\n        }\r\n    }, new PerfTestUtils.RunTest(FM) {\r\n\r\n        @Override\r\n        public Double call() throws Exception {\r\n            return JdkMath.pow(x, y);\r\n        }\r\n    });\r\n    PerfTestUtils.timeAndReport(\"exp\", maxWidth, numCall, numStat, false, new PerfTestUtils.RunTest(SM) {\r\n\r\n        @Override\r\n        public Double call() throws Exception {\r\n            return StrictMath.exp(x);\r\n        }\r\n    }, new PerfTestUtils.RunTest(M) {\r\n\r\n        @Override\r\n        public Double call() throws Exception {\r\n            return Math.exp(x);\r\n        }\r\n    }, new PerfTestUtils.RunTest(FM) {\r\n\r\n        @Override\r\n        public Double call() throws Exception {\r\n            return JdkMath.exp(x);\r\n        }\r\n    });\r\n    PerfTestUtils.timeAndReport(\"sin\", maxWidth, numCall, numStat, false, new PerfTestUtils.RunTest(SM) {\r\n\r\n        @Override\r\n        public Double call() throws Exception {\r\n            return StrictMath.sin(x);\r\n        }\r\n    }, new PerfTestUtils.RunTest(M) {\r\n\r\n        @Override\r\n        public Double call() throws Exception {\r\n            return Math.sin(x);\r\n        }\r\n    }, new PerfTestUtils.RunTest(FM) {\r\n\r\n        @Override\r\n        public Double call() throws Exception {\r\n            return JdkMath.sin(x);\r\n        }\r\n    });\r\n    PerfTestUtils.timeAndReport(\"asin\", maxWidth, numCall, numStat, false, new PerfTestUtils.RunTest(SM) {\r\n\r\n        @Override\r\n        public Double call() throws Exception {\r\n            return StrictMath.asin(x);\r\n        }\r\n    }, new PerfTestUtils.RunTest(M) {\r\n\r\n        @Override\r\n        public Double call() throws Exception {\r\n            return Math.asin(x);\r\n        }\r\n    }, new PerfTestUtils.RunTest(FM) {\r\n\r\n        @Override\r\n        public Double call() throws Exception {\r\n            return JdkMath.asin(x);\r\n        }\r\n    });\r\n    PerfTestUtils.timeAndReport(\"cos\", maxWidth, numCall, numStat, false, new PerfTestUtils.RunTest(SM) {\r\n\r\n        @Override\r\n        public Double call() throws Exception {\r\n            return StrictMath.cos(x);\r\n        }\r\n    }, new PerfTestUtils.RunTest(M) {\r\n\r\n        @Override\r\n        public Double call() throws Exception {\r\n            return Math.cos(x);\r\n        }\r\n    }, new PerfTestUtils.RunTest(FM) {\r\n\r\n        @Override\r\n        public Double call() throws Exception {\r\n            return JdkMath.cos(x);\r\n        }\r\n    });\r\n    PerfTestUtils.timeAndReport(\"acos\", maxWidth, numCall, numStat, false, new PerfTestUtils.RunTest(SM) {\r\n\r\n        @Override\r\n        public Double call() throws Exception {\r\n            return StrictMath.acos(x);\r\n        }\r\n    }, new PerfTestUtils.RunTest(M) {\r\n\r\n        @Override\r\n        public Double call() throws Exception {\r\n            return Math.acos(x);\r\n        }\r\n    }, new PerfTestUtils.RunTest(FM) {\r\n\r\n        @Override\r\n        public Double call() throws Exception {\r\n            return JdkMath.acos(x);\r\n        }\r\n    });\r\n    PerfTestUtils.timeAndReport(\"tan\", maxWidth, numCall, numStat, false, new PerfTestUtils.RunTest(SM) {\r\n\r\n        @Override\r\n        public Double call() throws Exception {\r\n            return StrictMath.tan(x);\r\n        }\r\n    }, new PerfTestUtils.RunTest(M) {\r\n\r\n        @Override\r\n        public Double call() throws Exception {\r\n            return Math.tan(x);\r\n        }\r\n    }, new PerfTestUtils.RunTest(FM) {\r\n\r\n        @Override\r\n        public Double call() throws Exception {\r\n            return JdkMath.tan(x);\r\n        }\r\n    });\r\n    PerfTestUtils.timeAndReport(\"atan\", maxWidth, numCall, numStat, false, new PerfTestUtils.RunTest(SM) {\r\n\r\n        @Override\r\n        public Double call() throws Exception {\r\n            return StrictMath.atan(x);\r\n        }\r\n    }, new PerfTestUtils.RunTest(M) {\r\n\r\n        @Override\r\n        public Double call() throws Exception {\r\n            return Math.atan(x);\r\n        }\r\n    }, new PerfTestUtils.RunTest(FM) {\r\n\r\n        @Override\r\n        public Double call() throws Exception {\r\n            return JdkMath.atan(x);\r\n        }\r\n    });\r\n    PerfTestUtils.timeAndReport(\"atan2\", maxWidth, numCall, numStat, false, new PerfTestUtils.RunTest(SM) {\r\n\r\n        @Override\r\n        public Double call() throws Exception {\r\n            return StrictMath.atan2(x, y);\r\n        }\r\n    }, new PerfTestUtils.RunTest(M) {\r\n\r\n        @Override\r\n        public Double call() throws Exception {\r\n            return Math.atan2(x, y);\r\n        }\r\n    }, new PerfTestUtils.RunTest(FM) {\r\n\r\n        @Override\r\n        public Double call() throws Exception {\r\n            return JdkMath.atan2(x, y);\r\n        }\r\n    });\r\n    PerfTestUtils.timeAndReport(\"hypot\", maxWidth, numCall, numStat, false, new PerfTestUtils.RunTest(SM) {\r\n\r\n        @Override\r\n        public Double call() throws Exception {\r\n            return StrictMath.hypot(x, y);\r\n        }\r\n    }, new PerfTestUtils.RunTest(M) {\r\n\r\n        @Override\r\n        public Double call() throws Exception {\r\n            return Math.hypot(x, y);\r\n        }\r\n    }, new PerfTestUtils.RunTest(FM) {\r\n\r\n        @Override\r\n        public Double call() throws Exception {\r\n            return JdkMath.hypot(x, y);\r\n        }\r\n    });\r\n    PerfTestUtils.timeAndReport(\"cbrt\", maxWidth, numCall, numStat, false, new PerfTestUtils.RunTest(SM) {\r\n\r\n        @Override\r\n        public Double call() throws Exception {\r\n            return StrictMath.cbrt(x);\r\n        }\r\n    }, new PerfTestUtils.RunTest(M) {\r\n\r\n        @Override\r\n        public Double call() throws Exception {\r\n            return Math.cbrt(x);\r\n        }\r\n    }, new PerfTestUtils.RunTest(FM) {\r\n\r\n        @Override\r\n        public Double call() throws Exception {\r\n            return JdkMath.cbrt(x);\r\n        }\r\n    });\r\n    PerfTestUtils.timeAndReport(\"sqrt\", maxWidth, numCall, numStat, false, new PerfTestUtils.RunTest(SM) {\r\n\r\n        @Override\r\n        public Double call() throws Exception {\r\n            return StrictMath.sqrt(x);\r\n        }\r\n    }, new PerfTestUtils.RunTest(M) {\r\n\r\n        @Override\r\n        public Double call() throws Exception {\r\n            return Math.sqrt(x);\r\n        }\r\n    }, new PerfTestUtils.RunTest(FM) {\r\n\r\n        @Override\r\n        public Double call() throws Exception {\r\n            return JdkMath.sqrt(x);\r\n        }\r\n    });\r\n    PerfTestUtils.timeAndReport(\"cosh\", maxWidth, numCall, numStat, false, new PerfTestUtils.RunTest(SM) {\r\n\r\n        @Override\r\n        public Double call() throws Exception {\r\n            return StrictMath.cosh(x);\r\n        }\r\n    }, new PerfTestUtils.RunTest(M) {\r\n\r\n        @Override\r\n        public Double call() throws Exception {\r\n            return Math.cosh(x);\r\n        }\r\n    }, new PerfTestUtils.RunTest(FM) {\r\n\r\n        @Override\r\n        public Double call() throws Exception {\r\n            return JdkMath.cosh(x);\r\n        }\r\n    });\r\n    PerfTestUtils.timeAndReport(\"sinh\", maxWidth, numCall, numStat, false, new PerfTestUtils.RunTest(SM) {\r\n\r\n        @Override\r\n        public Double call() throws Exception {\r\n            return StrictMath.sinh(x);\r\n        }\r\n    }, new PerfTestUtils.RunTest(M) {\r\n\r\n        @Override\r\n        public Double call() throws Exception {\r\n            return Math.sinh(x);\r\n        }\r\n    }, new PerfTestUtils.RunTest(FM) {\r\n\r\n        @Override\r\n        public Double call() throws Exception {\r\n            return JdkMath.sinh(x);\r\n        }\r\n    });\r\n    PerfTestUtils.timeAndReport(\"tanh\", maxWidth, numCall, numStat, false, new PerfTestUtils.RunTest(SM) {\r\n\r\n        @Override\r\n        public Double call() throws Exception {\r\n            return StrictMath.tanh(x);\r\n        }\r\n    }, new PerfTestUtils.RunTest(M) {\r\n\r\n        @Override\r\n        public Double call() throws Exception {\r\n            return Math.tanh(x);\r\n        }\r\n    }, new PerfTestUtils.RunTest(FM) {\r\n\r\n        @Override\r\n        public Double call() throws Exception {\r\n            return JdkMath.tanh(x);\r\n        }\r\n    });\r\n    PerfTestUtils.timeAndReport(\"expm1\", maxWidth, numCall, numStat, false, new PerfTestUtils.RunTest(SM) {\r\n\r\n        @Override\r\n        public Double call() throws Exception {\r\n            return StrictMath.expm1(x);\r\n        }\r\n    }, new PerfTestUtils.RunTest(M) {\r\n\r\n        @Override\r\n        public Double call() throws Exception {\r\n            return Math.expm1(x);\r\n        }\r\n    }, new PerfTestUtils.RunTest(FM) {\r\n\r\n        @Override\r\n        public Double call() throws Exception {\r\n            return JdkMath.expm1(x);\r\n        }\r\n    });\r\n    PerfTestUtils.timeAndReport(\"abs\", maxWidth, numCall, numStat, false, new PerfTestUtils.RunTest(SM) {\r\n\r\n        @Override\r\n        public Double call() throws Exception {\r\n            return StrictMath.abs(x);\r\n        }\r\n    }, new PerfTestUtils.RunTest(M) {\r\n\r\n        @Override\r\n        public Double call() throws Exception {\r\n            return Math.abs(x);\r\n        }\r\n    }, new PerfTestUtils.RunTest(FM) {\r\n\r\n        @Override\r\n        public Double call() throws Exception {\r\n            return JdkMath.abs(x);\r\n        }\r\n    });\r\n}",
    "summary": "该方法对StrictMath、Math和JdkMath库中的数学函数进行性能基准测试，比较其在log、log10、log1p、pow等函数上的执行效率。"
  },
  {
    "project": "commons-math",
    "className": "PerfTestUtils",
    "methodName": "timesAndResults",
    "complexity": 7,
    "loc": 53,
    "code": "/**\r\n * Timing.\r\n *\r\n * @param repeatChunk Each timing measurement will done done for that\r\n * number of repeats of the code.\r\n * @param repeatStat Timing will be averaged over that number of runs.\r\n * @param runGC Call {@code System.gc()} between each timed block. When\r\n * set to {@code true}, the test will run much slower.\r\n * @param methods Codes being timed.\r\n * @return for each of the given {@code methods} (first dimension), and\r\n * each of the {@code repeatStat} runs (second dimension):\r\n * <ul>\r\n *  <li>\r\n *   the average time (in milliseconds) taken by a single call to the\r\n *   {@code call} method (i.e. the time taken by each timed block divided\r\n *   by {@code repeatChunk})\r\n *  </li>\r\n *  <li>\r\n *   the result returned by the {@code call} method.\r\n *  </li>\r\n * </ul>\r\n */\r\n@SafeVarargs\r\npublic static double[][][] timesAndResults(int repeatChunk, int repeatStat, boolean runGC, Callable<Double>... methods) {\r\n    final int numMethods = methods.length;\r\n    final double[][][] timesAndResults = new double[numMethods][repeatStat][2];\r\n    // Indices into the array containing the methods to benchmark.\r\n    // The purpose is that at each repeat, the \"methods\" are called in a different order.\r\n    final int[] methodSequence = PermutationSampler.natural(numMethods);\r\n    try {\r\n        for (int k = 0; k < repeatStat; k++) {\r\n            PermutationSampler.shuffle(rng, methodSequence);\r\n            for (int n = 0; n < numMethods; n++) {\r\n                // Index of the timed method.\r\n                final int j = methodSequence[n];\r\n                if (runGC) {\r\n                    // Try to perform GC outside the timed block.\r\n                    System.gc();\r\n                }\r\n                final Callable<Double> r = methods[j];\r\n                final double[] result = new double[repeatChunk];\r\n                // Timed block.\r\n                final long start = System.nanoTime();\r\n                for (int i = 0; i < repeatChunk; i++) {\r\n                    result[i] = r.call().doubleValue();\r\n                }\r\n                final long stop = System.nanoTime();\r\n                // Collect run time.\r\n                timesAndResults[j][k][0] = (stop - start) * NANO_TO_MILLI;\r\n                // Keep track of a randomly selected result.\r\n                timesAndResults[j][k][1] = result[rng.nextInt(repeatChunk)];\r\n            }\r\n        }\r\n    } catch (Exception e) {\r\n        // Abort benchmarking if codes throw exceptions.\r\n        throw new MathIllegalStateException(LocalizedFormats.SIMPLE_MESSAGE, e.getMessage());\r\n    }\r\n    final double normFactor = 1d / repeatChunk;\r\n    for (int j = 0; j < numMethods; j++) {\r\n        for (int k = 0; k < repeatStat; k++) {\r\n            timesAndResults[j][k][0] *= normFactor;\r\n        }\r\n    }\r\n    return timesAndResults;\r\n}",
    "summary": "该方法对给定的多个代码方法进行重复性能测试，计算每个方法在多次运行中的平均执行时间（以毫秒为单位），并记录每次测试中随机选取的结果值。"
  },
  {
    "project": "commons-math",
    "className": "PerfTestUtils",
    "methodName": "timeAndReport",
    "complexity": 4,
    "loc": 68,
    "code": "/**\r\n * Timing and report (to standard output) the average time and standard\r\n * deviation of a single call.\r\n * The timing is performed by calling the\r\n * {@link #time(int,int,boolean,Callable[]) time} method.\r\n *\r\n * @param title Title of the test (for the report).\r\n * @param maxNameWidth Maximum width of the first column of the report.\r\n * @param repeatChunk Each timing measurement will done done for that\r\n * number of repeats of the code.\r\n * @param repeatStat Timing will be averaged over that number of runs.\r\n * @param runGC Call {@code System.gc()} between each timed block. When\r\n * set to {@code true}, the test will run much slower.\r\n * @param methods Codes being timed.\r\n * @return for each of the given {@code methods}, a statistics of the\r\n * average times (in milliseconds) taken by a single call to the\r\n * {@code call} method (i.e. the time taken by each timed block divided\r\n * by {@code repeatChunk}).\r\n */\r\n@SuppressWarnings(\"boxing\")\r\npublic static StatisticalSummary[] timeAndReport(String title, int maxNameWidth, int repeatChunk, int repeatStat, boolean runGC, RunTest... methods) {\r\n    // Header format.\r\n    final String hFormat = \"%s (calls per timed block: %d, timed blocks: %d, time unit: ms)\";\r\n    // TODO: user-defined parameter?\r\n    final boolean removePackageName = false;\r\n    // Width of the longest name.\r\n    int nameLength = 0;\r\n    for (RunTest m : methods) {\r\n        int len = shorten(m.getName(), removePackageName).length();\r\n        if (len > nameLength) {\r\n            nameLength = len;\r\n        }\r\n    }\r\n    final int actualNameLength = nameLength < maxNameWidth ? nameLength : maxNameWidth;\r\n    final String nameLengthFormat = \"%\" + actualNameLength + \"s\";\r\n    // Column format.\r\n    final String cFormat = nameLengthFormat + \" %9s %7s %10s %5s %4s %10s\";\r\n    // Result format.\r\n    final String format = nameLengthFormat + \" %.3e %.1e %.4e %.3f %.2f %.4e\";\r\n    System.out.println(String.format(hFormat, title, repeatChunk, repeatStat));\r\n    System.out.println(String.format(cFormat, \"name\", \"time/call\", \"std dev\", \"total time\", \"ratio\", \"cv\", \"difference\"));\r\n    final StatisticalSummary[] time = time(repeatChunk, repeatStat, runGC, methods);\r\n    final double refSum = time[0].getSum() * repeatChunk;\r\n    for (int i = 0, max = time.length; i < max; i++) {\r\n        final StatisticalSummary s = time[i];\r\n        final double sum = s.getSum() * repeatChunk;\r\n        final double mean = s.getMean();\r\n        final double sigma = s.getStandardDeviation();\r\n        System.out.println(String.format(format, truncate(shorten(methods[i].getName(), removePackageName), actualNameLength, ELLIPSIS), mean, sigma, sum, sum / refSum, sigma / mean, sum - refSum));\r\n    }\r\n    return time;\r\n}",
    "summary": "该方法对指定的测试方法进行性能测量，计算每个方法的平均执行时间、标准差等统计指标，并将结果以格式化报告形式输出到标准输出。"
  }
]